# **자바의 정석 기초편 정리(10장~16장)**

**책과 강의를 참고하여 Keyword 중심으로 정리 해보려 합니다.**  
※ 정리 내용은 [자바의 정석 - 기초편 2권] 강의, 책 등을 참고하였습니다.

[Ch10. 날짜와 시간 & 형식화](#Ch10-날짜와-시간-&-형식화)  
[Ch11. 컬렉션 프레임웍](#Ch11-컬렉션-프레임웍)  
[Ch12. 지네릭스, 열거형, 애너테이션](#Ch12-지네릭스-열거형-애너테이션)   


---------

### **Ch10. 날짜와 시간 & 형식화**

**날짜와 시간**
- java.util.Date
	- 날짜와 시간을 다룰 목적으로 만들어진 클래스(JDK1.0~)
	- Date의 메서드는 거의 deprecated 되었지만, 여전히 쓰이고 있다.
- java.util.Calendar
	- Date클래스를 개선한 새로운 클래스(JDK1.1). 여전히 단점 존재
- java.time 패키지
	- Date와 Calendar의 단점을 개선한 새로운 클래스들을 제공(JDK1.8)
	- 기초편에서는 다루지 않는다.(자바의 정석 3판 참고할 것)

**Calendar 클래스**
- 추상 클래스이므로 getInstance()를 통해 구현된 객체를 얻어야 한다.
```
Calendar cal = new Calendar(); // 에러!! 추상 클래스는 인스턴스를 생성할 수 없다.

//OK, getInstance() 메서드는 Calendar 클래스를 구현한 클래스의 인스턴스를 반환한다.
Calendar cal = Calendar.getInstance();
```
- get()으로 날짜와 시간 필드 가져오기 -> int get(int field)
```
Calendar cal = Calendar.getInstance();  // 현재 날짜와 시간으로 셋팅됨
int thisYear = cal.get(Calendar.YEAR);  // 올해가 몇년인지 알아낸다.
int lastDayOfMonth = cal.getActualMaximum(Calendar.DATE); // 이 달의 마지막 달
```
- Calendar 에 정의된 필드
![Calendar정의된필드](Calendar정의된필드.png)  
```
import java.util.Calendar;

class Ex10_1 {
	public static void main(String[] args) {
		// 기본적으로 현재 날짜와 시간으로 설정된다.
		Calendar today = Calendar.getInstance();
		System.out.println("이 해의 년도 : " + today.get(Calendar.YEAR));
		System.out.println("월(0~11, 0:1월): " + today.get(Calendar.MONTH));
		System.out.println("이 해의 몇 째 주 : " + today.get(Calendar.WEEK_OF_YEAR));
		System.out.println("이 달의 몇 째 주 : " + today.get(Calendar.WEEK_OF_MONTH));
		
		// DATE와 DAY_OF_MONTH 는 같다.
		System.out.println("이 달의 몇 일 : " + today.get(Calendar.DATE));
		System.out.println("이 달의 몇 일 : " + today.get(Calendar.DAY_OF_MONTH));
		System.out.println("이 해의 몇 일 : " + today.get(Calendar.DAY_OF_YEAR));
		System.out.println("요일(1~7, 1: 일요일): " + today.get(Calendar.DAY_OF_WEEK));
		System.out.println("이 달의 몇 째 요일 : " + today.get(Calendar.DAY_OF_WEEK_IN_MONTH));
		System.out.println("오전_오후(0:오전, 1:오후) : " + today.get(Calendar.AM_PM));
		System.out.println("시간(0~11) : " + today.get(Calendar.HOUR));
		System.out.println("시간(0~23) : " + today.get(Calendar.HOUR_OF_DAY));
		System.out.println("분(0~59) : " + today.get(Calendar.MINUTE));
		System.out.println("초(0~59) : " + today.get(Calendar.SECOND));
		System.out.println("1000분의 1초(0~999) : " + today.get(Calendar.MILLISECOND));
		
		// 천분의 1초를 시간으로 표시하기 위해 3600000으로 나누었다.(1시간 = 60*60초)
		System.out.println("TimeZone(-12~+12): " + today.get(Calendar.ZONE_OFFSET/3600000));
		System.out.println("이 달의 마지막 날 : " + today.getActualMaximum(Calendar.DATE));
	}
}

출력 : 
이 해의 년도 : 2021
월(0~11, 0:1월): 1
이 해의 몇 째 주 : 6
이 달의 몇 째 주 : 1
이 달의 몇 일 : 5
이 달의 몇 일 : 5
이 해의 몇 일 : 36
요일(1~7, 1: 일요일): 6
이 달의 몇 째 요일 : 1
오전_오후(0:오전, 1:오후) : 1
시간(0~11) : 5
시간(0~23) : 17
분(0~59) : 16
초(0~59) : 51
1000분의 1초(0~999) : 997
TimeZone(-12~+12): 1
이 달의 마지막 날 : 28
```
- set()으로 날짜와 시간 지정하기
```
void set(int field, int value)
void set(int year, int month, int date)
void set(int year, int month, int date, int hourIfDay, int minute)
void set(int year, int month, int date, int hourOfDay, int minute, int second)
```
- 날짜 지정하는 방법. 월(MONTH)이 0부터 시작한다는 점 주의!!
```
Calendar date1 = Calendar.getInstance();
date1.set(2017,7,15); // 2017년 8월 15일(7월 아님)
// date1.set(Calendar.YEAR, 2017);
// date1.set(Calendar.MONTH, 7);
// date1.set(Calendar.DATE, 15);
```
```
import java.util.*;

class Ex10_2 {
	public static void main(String[] args) {
		//요일은 1부터 시작하기 때문에, DAY_OF_WEEK[0]은 비워둠
		final String[] DAY_OF_WEEK = {"","일","월","화","수","목","금","토"};
		
		Calendar date1 = Calendar.getInstance();
		Calendar date2 = Calendar.getInstance();
		
		// month의 경우 0부터 시작하기 때문에 4월인 경우, 3으로 지정해야한다.
		// date1.set(2019, Calendar.APRIL, 29); 와 같이 할 수도 있다. 
		date1.set(2019, 3, 29); // 2019년 4월 29일로 날짜를 설정한다.
		System.out.println("date1은 " + toString(date1)+ 
				DAY_OF_WEEK[date1.get(Calendar.DAY_OF_WEEK)] + "요일이고,");
		System.out.println("오늘(date2)은 " + toString(date2) + 
				DAY_OF_WEEK[date2.get(Calendar.DAY_OF_WEEK)] + "요일입니다."  );
		
		// 두 날짜 간의 차이를 얻으려면, getTimeInMillis() 천분의 일초 단위로 변환해야한다.
		long difference = (date2.getTimeInMillis() - date1.getTimeInMillis())/1000;
		System.out.println("그 날(date1)부터 지금(date2)까지 " + difference + "초가 지났습니다.");
		System.out.println("일로 환산하면 " + difference/(24*60*60) + "일이 됩니다.");
		
	}
	
	static String toString(Calendar date) {
		return date.get(Calendar.YEAR) + "년 " + (date.get(Calendar.MONTH)+1) + 
				"월 " + date.get(Calendar.DATE) + "일 ";
	}
}

출력:
date1은 2019년 4월 29일 월요일이고,
오늘(date2)은 2021년 2월 5일 금요일이다.
그 날(date1)부터 지금(date2)까지 55987200초가 지났습니다.
일로 환산하면 648일이 됩니다.
```
- 시간 지정하는 방법. 시,분,초 별도 설정 필요.
```
Calendar time1 = Calendar.getInstance();
time1.set(Calendar.HOUR_OF_DAY, 10);
time1.set(Calendar.MINUTE, 20);
time1.set(Calendar.SECOND, 30);
```
```
import java.util.Calendar;

public class Ex10_3 {
	public static void main(String[] args) {
		final int[] TIME_UNIT = {3600, 60, 1};
		final String[] TIME_UNIT_NAME = {"시간 ", "분 ", "초 "};
		
		Calendar time1 = Calendar.getInstance();
		Calendar time2 = Calendar.getInstance();
		
		// time1의 시간을 10시 20분 30초로 설정
		timeSet(time1,10,20,30);
		// time2의 시간을 20시 30분 10초로 설정
		timeSet(time2,20,30,10);
		
		System.out.println("time1 : "+timeToString(time1));
		System.out.println("time2 : "+timeToString(time2));
		
		long difference = 
				Math.abs(time2.getTimeInMillis()-time1.getTimeInMillis())/1000;
		System.out.println("time1과 time2의 차이는 "+difference+"초 입니다.");
		
		String tmp = "";
		// 거스름돈 구하는 알고리즘과 유사함(큰 단위부터 나눠준다.)
		for(int i = 0; i < TIME_UNIT.length; i++) {
			tmp += difference/TIME_UNIT[i] + TIME_UNIT_NAME[i];
			difference %= TIME_UNIT[i];
		}
		System.out.println("시분초로 환산하면, "+tmp+"입니다.");
	}
	
	static void timeSet(Calendar date, int hour, int min, int sec) {
		date.set(Calendar.HOUR_OF_DAY, hour);
		date.set(Calendar.MINUTE, min);
		date.set(Calendar.SECOND, sec);
	}
	
	static String timeToString(Calendar date) {
		return date.get(Calendar.HOUR_OF_DAY)+"시 "+date.
				get(Calendar.MINUTE)+"분 "+date.get(Calendar.SECOND)+"초 ";
	}
}

출력:
time1 : 10시 20분 30초 
time2 : 20시 30분 10초 
time1과 time2의 차이는 36580초 입니다.
시분초로 환산하면, 10시간 9분 40초 입니다.
```
- clear()는 Calendar 객체의 모든 필드를 초기화
- 날짜 및 시간을 설정하기 전에 clear()를 통해 초기화를 해주는 것이 좋다.
```
Calendar dt = Calendar.getInstance();

// Fri Feb 05 19:05:59 KST 2021
System.out.println(new Date(dt.getTimeInMillis()));

dt.clear();
// Thu Jan 01 00:00:00 KST 2017 <- EPOCH Time
System.out.println(new Date(dt.getTimeInMillis()));
```
- clear(int field)는 Calendar 객체의 특정 필드를 초기화
```
Calendar dt = Calendar.getInstance();

// Fri Feb 05 19:05:59 KST 2021
System.out.println(new Date(dt.getTimeInMillis()));

dt.clear(Calendar.SECOND);
dt.clear(Calendar.MINUTE);
dt.clear(Calendar.HOUR_OF_DAY);
dt.clear(Calendar.HOUR);

// Fri Feb 05 00:00:00 KST 2021
System.out.println(new Date(dt.getTimeInMillis()));
```
- add() 는 특정 필드의 값을 증가 또는 감소(다른 필드에 영향O)
```
Calendar date = Calendar.getInstance();
date.clear(); // 모든 필드를 초기화
date.set(2020,7,31); // 2020년 8월 31일로 설정

date.add(Calendar.DATE, 1); // 날짜(DATE)에 1을 더한다. -> 9월 1일로 변경
date.add(Calendar.MONTH, -8); // 월(MONTH)에서 8을 뺀다.
```
- roll()은 특정필드의 값을 증가 또는 감소(다른 필드에 영향X)
```
date.set(2020,7,31); // 2020년 8월 31일로 설정

// add()와 달리 roll()은 다른 필드에 영향을 미치지 않는다.
date.roll(Calendar.DATE, 1); // 날짜(DATE)에 1을 더한다. -> 8월 1일로 변경
date.roll(Calendar.MONTH, -8); // 월(MONTH)에서 8을 뺀다.
```
```
import java.util.Calendar;

class Ex10_4 {
	public static void main(String[] args) {
		Calendar date = Calendar.getInstance();
		date.set(2019, 7, 31); // 2019년 8월 31일
		
		System.out.println(toString(date));
		System.out.println("= 1일 후 =");
		date.add(Calendar.DATE, 1);
		System.out.println(toString(date));
		
		System.out.println("= 6달 전 =");
		date.add(Calendar.MONTH, -6);
		System.out.println(toString(date));
		
		// add()와 달리 roll()은 다른 필드에 영향을 주지 않는다.
		System.out.println("= 31일 후(roll) =");
		date.roll(Calendar.DATE, 31);
		System.out.println(toString(date));
		
		System.out.println("= 31일 후(add) =");
		date.add(Calendar.DATE, 31);
		System.out.println(toString(date));
		
	}
	
	static String toString(Calendar date) {
		return date.get(Calendar.YEAR)+"년 "+(date.get(Calendar.MONTH)+1)+"월 "+
			date.get(Calendar.DATE)+"일 ";
	}
}

출력 :
2019년 8월 31일 
= 1일 후 =
2019년 9월 1일 
= 6달 전 =
2019년 3월 1일 
= 31일 후(roll) =
2019년 3월 1일 
= 31일 후(add) =
2019년 4월 1일 
```

**Date와 Calendar 간의 변환**
- Date의 메서드는 대부분 deprecated 되었지만 여전히 사용
- Calendar를 Date로 변환
```
Calendar cal = Calendar.getInstance();
...
Date d = new Date(cal.getTimeInMillis()); // Date(long date)
```
- Date를 Calendar로 변환
```
Date d = new Date();
...
Calendar cal = Calendar.getInstance();
cal.setTime(d)
```

**형식화 클래스**
- java.text패키지의 DecimalFormat, SimpleDateFormat
- 숫자와 날짜를 원하는 형식으로 쉽게 출력 가능(숫자, 날짜 -> 형식 문자열)
```
double number = 1234567.89;
DecimalFormat df = new DecimalFormat("#.#E0");
String result = df.format(number); // result = "1.2E6"
```
- 형식 문자열에서 숫자와 날짜를 뽑아내는 기능(형식 문자열 -> 숫자, 날짜)
```
DecimalFormat df = new DecimalFormat("#,###.##");
Number num = df.parse("1,234,567.89");
double d = num.doubleValue(); // 1234567.89
```

**DecimalFormat**
- 숫자를 형식화할 때 사용(숫자 -> 형식 문자열)
- 특정 형식의 문자열을 숫자로 변환할 때도 사용(형식 문자열 -> 숫자)
- 참고. Integer.parseInt()와 같은 형태의 메서드는 콤마','가 포함된 문자열을 숫자로 변환 못함
![DecimalFormat](DecimalFormat.png)  

**SimpleDateFormat**
- 날짜와 시간을 다양한 형식으로 출력할 수 있게 해준다.
```
Date today = new Date();
SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd");

// 오늘 날짜를 yyyy-MM-dd 형태로 변환하여 반환
String result = df.format(today);
```
- 특정 형식으로 되어있는 문자열에서 날짜와 시간을 뽑아낼 수도 있다.
```
DateFormat df = new SimpleDateFormat("yyyy년 MM월 dd일");
DateFormat d2 = new StimplDateFormat(yyyy/MM/dd);

Date d = df.parse("2015년 11월 23일");
String result = df2.format(d);
```
![SimpleDateFormat](SimpleDateFormat.png)  

### **Ch11. 컬렉션 프레임웍**

**컬렉션 프레임웍**
- 컬렉션(collection) : 여러 객체(데이터)를 모아 놓은 것을 의미
- 프레임웍(framework) : 표준화, 정형화된 체계적인 프로그래밍 방식
	- 생산성이 올라가고, 유지보수가 용이해진다.
- 컬렉션 프레임웍(collections framework)
	- 컬렉션(다수의 객체)을 다루기 위한 표준화된 프로그래밍 방식)
	- 컬렉션을 쉽고 편리하게 다룰 수 있는 다양한 클래스를 제공
	- java.util 패키지에 포함. JDK1.2부터 제공
- 컬렉션 클래스(collection class)
	- 다수의 데이터를 저장할 수 있는 클래스(예, Vector, ArrayList,HashSet)

**컬렉션 프레임웍의 핵심 인터페이스**
![컬렉션프레임웍인터페이스](컬렉션프레임웍인터페이스.png)
 
**Collection 인터페이스의 메서드**
![Collection인터페이스메서드](Collection인터페이스메서드.png)

**List 인터페이스 - 순서O, 중복O**
![List인터페이스](List인터페이스.png)  
![List인터페이스메서드](List인터페이스메서드.png)  

**Set 인터페이스 - 순서X, 중복X**
![Set인터페이스](Set인터페이스.png)  
- Set 인터페이스의 메서드는 Collection 인터페이스와 동일  
![Set인터페이스메서드](Set인터페이스메서드.png)  
- 집합과 관련된 메서드(Collection에 변화가 있으면 true, 아니면 false 반환  
![Set인터페이스집합메서드](Set인터페이스집합메서드.png)  

**Map 인터페이스 - 순서X, 중복(키X,값O)**
![Map인터페이스](Map인터페이스.png)  
![Map인터페이스메서드](Map인터페이스메서드.png)  

**ArrayList**
- ArrayList는 기존의 Vector를 개선한 것으로 구현 원리와 기능적으로 동일
- ArrayList와 달리 Vector는 자체적으로 동기화처리가 되어 있다.
- List인터페이스를 구현하므로, 저장순서가 유지되고 중복을 허용한다.
- 데이터의 저장공간으로 배열을 사용한다.(배열기반)
```
public class Vector extends AbstractList
	implements List, RandomAccess, Cloneable, java.io.Serializable {
	...
	protected Object[] elementData; // 모든 종류의 객체 저장 가능
	...
```

**ArrayList의 메서드**  
![ArrayList메서드](ArrayList메서드.png)  
```
import java.util.ArrayList;
import java.util.Collections;

class Ex11_1 {
	public static void main(String[] args) {
		// 기본 길이(용량, capacity)가 10인 ArrayList를 생성
		ArrayList list1 = new ArrayList(10);
		// ArrayList에는 객체만 저장 가능
		// autoboxing에 의해 기본형이 참조형으로 자동 변환
		list1.add(5); // list1.add(new Integer(5));
		list1.add(new Integer(4));
		list1.add(new Integer(2));
		list1.add(new Integer(0));
		list1.add(new Integer(1));
		list1.add(new Integer(3));
		
		ArrayList list2 = new ArrayList(list1.subList(1, 4)); // ArrayList(Collection c) 사
		print(list1, list2);
		 
		// Collection은 인터페이스, Collections는 유틸 클래스
		Collections.sort(list1);
		Collections.sort(list2);
		print(list1, list2);
		
		System.out.println("list1.containsAll(list2) : "+list1.containsAll(list2));
		
		list2.add("B");
		list2.add("c");
		list2.add(3,"a");
		print(list1, list2);
		
		list2.set(3, "AA");
		print(list1, list2);
		
		// "1"을 찾으면 index=0, 1을 찾으면 index=2
		list1.add(0, "1");
		System.out.println("index = "+list1.indexOf(1));
		
		// 입력값의 자료형을 명확히 해주어야 한다.
		list1.remove(1); // Object remove(int index) 사용
		list1.remove(new Integer(1)); // boolean remove(Object o) 사용
		list1.remove("1"); // boolean remove(Object o) 사
		print(list1,list2);
		
		// list1에서 list2와 겹치는 부분만 남기고 나머지는 삭제한다.
		System.out.println("list1.retainAll(list2) : "+list1.retainAll(list2));
		print(list1, list2);
		
		// list2에서 list1에 포함된 객체들을 삭제한다.
		for(int i = list2.size()-1;i >=0; i--) {
			if(list1.contains(list2.get(i))) {
				list2.remove(i);
			}
		} 
		print(list1, list2);
	} // main의 끝
	
	static void print(ArrayList list1, ArrayList list2) {
		System.out.println("list1 : "+ list1);
		System.out.println("list2 : "+ list2);
		System.out.println();
	}
}

출력 :
list1 : [5, 4, 2, 0, 1, 3]
list2 : [4, 2, 0]

list1 : [0, 1, 2, 3, 4, 5]
list2 : [0, 2, 4]

list1.containsAll(list2) : true
list1 : [0, 1, 2, 3, 4, 5]
list2 : [0, 2, 4, a, B, c]

list1 : [0, 1, 2, 3, 4, 5]
list2 : [0, 2, 4, AA, B, c]

index = 2
list1 : [2, 3, 4, 5]
list2 : [0, 2, 4, AA, B, c]

list1.retainAll(list2) : true
list1 : [2, 4]
list2 : [0, 2, 4, AA, B, c]

list1 : [2, 4]
list2 : [0, AA, B, c]
```

**ArrayList에 저장된 객체의 삭제 과정 1**
- ArrayList에 저장된 세 번째 데이터(data[2])를 삭제하는 과정. list.remove(2);를 호출
![ArrayList저장객체삭제과정1](ArrayList저장객체삭제과정1.png)  

**ArrayList에 저장된 객체의 삭제 과정 2**
![ArrayList저장객체삭제과정2](ArrayList저장객체삭제과정2.png)  

**배열의 장단점**
- 장점 : 배열은 구조가 간단하고 데이터를 읽는데 걸리는 시간(접근시간, access time)이 짧다.
- 단점1 : 크기를 변경할 수 없다.
	- 크기를 변경해야 하는 경우 새로운 배열을 생성 후 데이터를 복사해야 함.
	- 크기 변경을 피하기 위해 충분히 큰 배열을 생성하면, 메모리가 낭비됨.
- 단점2 : 비순차적인 데이터의 추가, 삭제에 시간이 많이 걸린다.
	- 데이터를 추가하거나 삭제하기 위해, 다른 데이터를 옮겨야 함.
	- 그러나 순차적인 데이터 추가(끝에 추가)와 삭제(끝부터 삭제)는 빠르다.

**LinkedList - 배열의 단점을 보완**
- 배열과 달리 LinkedList는 불연속적으로 존재하는 데이터를 연결(link)
- 데이터의 삭제 : 단 한 번의 참조 변경만으로 가능
![LinkedList1](LinkedList1.png)  
- 데이터의 추가 : 한 번의 Node객체 생성과 두 번의 참조 변경만으로 가능
![LinkedList2](LinkedList2.png)  

**LinkedList - 이중 연결 리스드**
- 링크드 리스트(linked list) : 연결 리스트. 데이터 접근성이 나쁨
![링크드리스트](링크드리스트.png)  
- 더블리 링크드 리스트(doubly linked list) : 이중 연결 리스트, 접근성 향상
![더블리링크드리스트](더블리링크드리스트.png)  
- 더블리 써큘러 링크드 리스트(doubly circular linked list) : 이중 원형 연결 리스트
![더블리써큘러링크드리스트](더블리써큘러링크드리스트.png)  

**ArrayList vs. LinkedList - 성능비교**  
![list성능비교](list성능비교.png)  

**스택과 큐(Stack & Queue)**
- 스택(Stack) : LIFO(Last In First Out)구조. 마지막에 저장된 것을 제일 먼저 꺼내게 된다.
	- 스택은 밑이 막힌 상자!
- 큐(Queue) : FIFO(First In First Out)구조. 제일 먼저 저장한 것을 제일 먼저 꺼내게 된다.  
![Stack과Queue](Stack과Queue.png)  

**스택과 큐(Stack & Queue)의 메서드**
![스택과큐메서드](스택과큐메서드.png)  

**인터페이스를 구현한 클래스 찾기**  
![인터페이스구현클래스](인터페이스구현클래스.png)  
```
import java.util.LinkedList;
import java.util.Queue;
import java.util.Stack;

class Ex11_2 {
	public static void main(String[] args) {
		Stack st = new Stack();
		Queue q = new LinkedList();
		
		st.push("0");
		st.push("1");
		st.push("2");
		
		q.offer("0");
		q.offer("1");
		q.offer("2");
		
		System.out.println("= Stack =");
		while(!st.empty()) {              // 스택이 비어있지 않다면,
			System.out.println(st.pop()); // 스택에서 요소 하나를 꺼내서 나타낸다.
		}
		
		System.out.println("= Queue =");
		while(!q.isEmpty()) {             // 큐가 비어있지 않다면,
			System.out.println(q.poll()); // 큐에서 요소 하나를 꺼내서 나타낸다.
		}
	}
}

출력 : // Stack 과 Queue 의 출력 순서가 반대로 되어있는 것을 볼 수 있음. 
= Stack =
2
1
0
= Queue =
0
1
2
```

**스택과 큐(Stack & Queue)의 활용**
- 스택의 활용 예 : 수식계산, 수식괄호검사, 워드프로세서의 undo/redo, 웹브라우저의 뒤로/앞으로
- 큐의 활용 예 : 최근사용문서, 인쇄작업 대기목록, 버퍼(buffer)
```
// 수식괄호검사 예제
import java.util.EmptyStackException;
import java.util.Stack;

class Ex11_3 {
	public static void main(String[] args) {
		if(args.length != 1) {
			System.out.println("Usage:java Ex11_3 \"EXPRESSION\"");
			System.out.println("Example:java Ex11_3 \"((2+3)*1)+3\"");
			System.exit(0);
		}
		
		Stack st = new Stack();
		String expression = args[0];
		
		System.out.println("expression : " + expression);
		
		try {
			for(int i = 0; i < expression.length(); i++) {
				char ch = expression.charAt(i);
				
				if(ch=='(') {
					st.push("(");
				}else if(ch==')') {
					st.pop();
				}
			}
			
			if(st.isEmpty()) {
				System.out.println("괄호가 일치합니다.");
			}else {
				System.out.println("괄호가 일치하지 않습니다.");				
			}			
		} catch(EmptyStackException e){ // ')'가 많을 때 Stack이 비어있는 경우 발생
			System.out.println("괄호가 일치하지 않습니다.");
		} // try
	} // main
}
```
```
// 최근 명령어(5개) 저장 예제
import java.util.LinkedList;
import java.util.ListIterator;
import java.util.Queue;
import java.util.Scanner;

class Ex11_4 {
	static Queue q = new LinkedList(); // Queue 사용할 때 Queue를 구현한 class를 사용한다.
	static final int MAX_SIZE = 5; // Queue에 최대 5개까지만 저장되도록 한다.(save())
	
	public static void main(String[] args) {
		System.out.println("help를 입력하면 도움말을 볼 수 있습니다.");
		
		while(true) {
			System.out.print(">>");
			try {
				// 화면으로부터 라인단위로 입력받는다.
				Scanner s = new Scanner(System.in);
				String input = s.nextLine().trim(); // trim() : 좌우 공백 없애줌
				
				if("".equals(input)) {
					continue; // 나머지 반복문 건너띄고 조건문(while)으로 이동
				}
				
				// boolean equalsIgnoreCase(String s) : 대소문자 구분없이 같을 경우 true 
				if(input.equalsIgnoreCase("q")) { 
					System.exit(0);
				}else if(input.equalsIgnoreCase("help")){
					System.out.println(" help - 도움말을 보여줍니다.");
					System.out.println(" q 또는 Q - 프로그램을 종료합니다.");
					System.out.println(" history - 최근 입력한 명령어"+MAX_SIZE+"개 보여줍니다.");
				}else if(input.equalsIgnoreCase("history")) {
					
					int i = 0;
					
					save(input);
					
					// LinkedList 의 내용을 보여준다.
					LinkedList tmp = (LinkedList)q;
					ListIterator it = tmp.listIterator(); // List를 가로지르는 객체 it
					
					// boolean hasNext() : Returns true if this list iterator has more elements 
					//                    when traversing the list in the forward direction.
					while(it.hasNext()) {
						// E next() : Returns the next element in the list and advances 
						//           the cursor position.
						System.out.println(++i+"."+it.next());
					}
				} else { 
					save(input);
					System.out.println(input);
				}
			}catch(Exception e) {
				System.out.println("입력오류입니다.");
			}
		}
	}
	
	static void save(String input) {
		// Queue에 저장한다.
		if(!"".equals(input)) { // 빈문자열은 저장하지 않는다.
			q.offer(input); // 큐에 명령어를 저장
		}
		// queue의 최대크기를 넘으면 제일 처음에 입력된 것을 삭제한다.
		if(q.size() > MAX_SIZE) { // size()는 Collection 인터페이스에 정의
			q.remove();
		}
	}
	
} // end of class
```

**Iterator, ListIterator, Enumeration**
- 컬렉션에 저장된 데이터를 접근하는데 사용되는 인터페이스
- Enumeration은 Iterator의 구버전
- ListIterator는 Iterator는 Iterator의 접근성을 향상시킨 것(단방향 -> 양방향)
![IteratorEnumeration](IteratorEnumeration.png)  
- **컬렉션(list, set, map)**에 저장된 요소들을 읽어오는 방법을 표준화한 것
```
public interface Collection {
	...
	public Iterator iterator();
	...
}
```
```
List list = new ArrayList(); // 다른 컬렉션으로 변경할 때는 이 부분만 고치면 된다.
Iterator it = list.iterator();

while(it.hasNext()) { // boolean hasNext() 읽어올 요소가 있는지 확인
	System.out.println(it.next()); // Object next() 다음 요소를 읽어옴
}
```
```
import java.util.ArrayList;
import java.util.Iterator;

class Ex11_5 {
	public static void main(String[] args) {
		ArrayList list = new ArrayList();
		list.add("1");
		list.add("2");
		list.add("3");
		list.add("4");
		list.add("5");
		
		// iterator를 통한 출력. 
		// Collection 메서드이므로 인터페이스가 바뀌어도 계속 사용 가능
		Iterator it = list.iterator();
		while(it.hasNext()) {
			Object obj = it.next();
			System.out.println(obj);
		}

		// iterator는 1회용으로 다쓰고나면 다시 얻어와야한다.
		it = list.iterator();
		while(it.hasNext()) {
			Object obj = it.next();
			System.out.println(obj);
		}
		
		// for문을 통한 출력. 
		// get()과 같은 메서드가 정의되어있지 않은 인터페이스로 바뀌면 사용 불가할 수 있다.
		for(int i = 0; i < list.size(); i++) {
			Object obj = list.get(i);
			System.out.println(obj);
		}
	}
}
```

**Map과 Iterator**
- Map에는 ierator()가 없다. keySet(), entrySet(), values()를 호출해야 한다.
```
Map map = new HashMap();
...
Iterator it = map.entrySet().iterator();
```
1. map.entrySet()을 통해 Set을 얻고,
	- Iterator it = map.entrySet().iterator();
	- Iterator it = Set인스턴스.iterator();
2. map.entrySet()를 통해 얻은 Set인스턴스의 iterator()를 호출해서 Iterator인스턴스를 얻는다.
	- Iterator it = Set인스턴스.iterator();
	- Iterator it = Iterator인스턴스;
3. 마지막으로 Iterator인스턴스의 참조가 it에 저장된다.

**Arrays**
- 배열을 다루기 편리한 메서드(static) 제공
1. 배열의 출력 : toString()
```
static String toString(boolean[] a)
static String toString(byte[] a)
static String toString(char[] a)
static String toString(short[] a)
static String toString(int[] a)
static String toString(long[] a)
static String toString(float[] a)
static String toString(double[] a)
static String toString(Object[] a)
```
2. 배열의 복사 : copyOf(), copyOfRange()
```
int[] arr = {0,1,2,3,4};
int[] arr2 = Arrays.copyOf(arr, arr.length); // arr2 = [0,1,2,3,4]
int[] arr3 = Arrays.copyOf(arr, 3);          // arr3 = [0,1,2] 
int[] arr4 = Arrays.copyOf(arr, 7);          // arr4 = [0,1,2,3,4,0,0]
int[] arr5 = Arrays.copyOfRange(arr, 2, 4);  // arr5 = [2,3]
int[] arr6 = Arrays.copyOfRange(arr, 0, 7);  // arr6 = [0,1,2,3,4,0,0]
```
3. 배열 채우기 : fill(), setAll()
```
int[] arr = new int[5];
Arrays.fill(arr, 9); // arr = [9,9,9,9,9]
Arrays.setAll(arr, (i) -> (int)(Math.random()*5)+1); // arr = [1,5,2,3,2]
```

4. 배열의 정렬과 검색 : sort(), binarySearch()
```
static void sort(Object[] a) // 객체 배열에 저장된 객체가 구현한 Comparable에 의한 정렬
static void sort(Object[] a, Comparator c) // 지정한 Comparator에 의한 정렬
```
```
int[] arr = {3,2,0,1,4};
int idx = Arrays.binarySearch(arr,2);      // idx = -5 <- 잘못된 결과

Arrays.sort(arr);
System.out.println(Arrays.toString(arr));  // [0,1,2,3,4]
int idx = Arrays.binarySearch(arr,2));     // idx = 2 <- 올바른 결과. 정렬을 먼저 해줘야함
```

5. 다차원 배열의 출력 : deepToString()
```
int[] arr = {0,1,2,3,4};
int[][] arr2D = {{11,12},{21,22}};

System.out.println(Arrays.toString(arr)); // [0,1,2,3,4]
System.out.println(Arrays.deepToString(arr2D)); // [[11,12],[21,22]]
``` 

6. 다차원 배열의 비교 : deepEquals()
```
String[][] str2D = new String[][]{{"aaa","bbb"},{"AAA","BBB"}};
String[][] str2D2 = new String[][]{{"aaa","bbb"},{"AAA"."BBB"}};

System.out.println(Arrays.equals(str2D, str2D2));
System.out.println(Arrays.deepEquals(str2D, str2D2));
```

7. 배열을 List로 변환 : asList(Object...) <- 괄호 안은 '배열'
```
List list = Arrays.asList(new Integer[]{1,2,3,4,5});
List list = Arrays.asList(1,2,3,4,5);
list.add(6); // UnsupportedOperationException 예외 발생. 읽기 전용이므로.

List list = new ArrayList(Arrays.asList(1,2,3,4,5));
```

8. 람다와 스트림 관련 : parallelXXX(), spliterator(), stream()


**Comparator와 Comparable**
- 객체 정렬에 필요한 메서드(정렬기준 제공)를 정의한 인터페이스
	- Comparable : 기본 정렬기준을 구현하는데 사용
	- Comparator : 기본 정렬기준 외에 다른 기준으로 정렬하고자할 때 사용
```
public interface Comparator {
	int compare(Object o1, Object o2); // o1, o2 두 객체를 비교
	boolean equals(Object obj); // equals를 오버라이딩하라는 뜻
}

public interface comparable {
	int compareTo(Object o); // 주어진 객체(o)를 자신과 비교
}
```
- compare()와 compareTo()는 두 객체의 비교결과를 반환하도록 작성
	- 같으면 0, 오른쪽이 크면 음수(-), 작으면 양수(+)
```
public final class Integer extends Number implements Comparable {
	...
	public int t compareTo(Integer anotherInteger) {
		int v1 = this.value;
		int v2 = anotherInteger.value;
		// 같으면 0, 오른쪽 값이 크면 -1, 작으면 1 반환
		return v1 < v2 ? -1 : (v1 == v2 ? 0 : 1);
	}
	...
}
```
```
import java.util.Arrays;
import java.util.Comparator;

class Ex11_7 {
	public static void main(String[] args) {
		String[] strArr = {"cat", "Dog", "lion","tiger"};

		Arrays.sort(strArr); // String의 Comparable 구현에 의한 정렬
		System.out.println("strArr = "+Arrays.toString(strArr)); // strArr = [Dog, cat, lion, tiger]
		
		Arrays.sort(strArr, String.CASE_INSENSITIVE_ORDER); // 대소문자 구분안함
		System.out.println("strArr = "+Arrays.toString(strArr)); // strArr = [cat, Dog, lion, tiger]
		
		Arrays.sort(strArr, new Descending()); // 역순 정렬
		System.out.println("strArr = "+Arrays.toString(strArr)); // strArr = [tiger, lion, cat, Dog]
	}

}

class Descending implements Comparator {
	public int compare(Object o1, Object o2) {
		if(o1 instanceof Comparable && o2 instanceof Comparable) {
			Comparable c1 = (Comparable)o1;
			Comparable c2 = (Comparable)o2;
			return c1.compareTo(c2) * -1 ; // -1을 곱해서 기본 정렬방식의 역으로 변경
			// 또는 c2.compareTo(c1)와 같이 순서를 바꿔도 된다.
		}
		return -1;
	}
}
```
 
**Integer와 Comparable**
- 크기 비교를 명확히 할 수 있는 요소는 정렬 기준을 가지고 있다.
```
public final class Integer Extends Nuymber implements Comarable {
	...
	public int compareTo(Object o) {
		return compareTo((Integer)o);
	}
	public int compareTo(Integer anotherInteger) {
		int thisVal = this.value;
		int anotherVal = anotherInteger.value;

		// 비교하는 값이 크면 -1, 같으면 0 , 작으면 1을 반환한다.
		return(thisVal<anotherVal ? -1 : (thisVal==anotherVal ? 0 : -1))
	}
	...
}
```

**HashSet - 순서 X, 중복 X**
- Set 인터페이스를 구현한 대표적인 컬렉션 클래스(순서 X, 중복 X)
- 순서를 유지하려면, LinkedHashSet 클래스를 사용하면 된다.
![HashSet주요메서드](HashSet주요메서드.png)  
```
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;

class Ex11_9 {
	public static void main(String[] args) {
		// "1" 과 new Integer(1) 은 문자열과 integer 객체로 형태가 달라 다른 객체이다.(둘 다 저장)
		Object[] objArr = {"1", new Integer(1), "2","2","3","3","4","4"};
		Set set = new HashSet();
		
		for(int i = 0; i < objArr.length; i++) {
			set.add(objArr[i]); // HashSet에 objArr의 요소들을 저장한다.
		}
		// HashSet에 저장된 요소들을 출력한다.
		System.out.println(set);
		
		// HashSet에 저장된 요소들을 출력한다.(Iterator 이용)
		Iterator it = set.iterator();
		
		while(it.hasNext()) { // 읽어올 요소가 남아있는지 확인
			System.out.println(it.next()); // 요소 하나 꺼내오기
		}
	}
}
```
```
import java.util.Collections;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;

class Ex11_10 {
	public static void main(String[] args) {
		Set set = new HashSet();
		
		for(int i = 0; set.size() < 6; i++) {
			int num = (int)(Math.random()*45)+1;
			set.add(new Integer(num)); // new Integer() 생략 가능
		}
		
		System.out.println(set); // [3, 26, 43, 29, 15, 31]
		
		// Set은 정렬불가하므로, List로 변경해준 후에 정렬
		List list = new LinkedList(set); // LinkedList(Collection c)
		Collections.sort(list); // Collections.sort(List list)
		System.out.println(list); //[3, 15, 26, 29, 31, 43]
	}
}
```
- HashSet은 객체를 저장하기 전에 기존에 같은 객체가 있는지 확인  
- 같은 객체가 없으면 저장하고, 있으면 저장하지 않는다.
- boolean add(Object o)는 저장할 객체의 equals()와 hashCode()를 호출
- equals()와 hashCode()가 오버라이딩되어 있어야 함
```
import java.util.HashSet;
import java.util.Objects;

class Ex11_11 {
	public static void main(String[] args) {
		HashSet set = new HashSet();
		
		set.add("abc");
		set.add("abc");
		set.add(new Person("David",10));
		set.add(new Person("David",10));
		
		System.out.println(set);
	}
}

class Person {
	String name;
	int age;
	
	Person(String name, int age) {
		this.name = name;
		this.age = age;
	}
	
	public String toString() {
		return name + ":" + age
	}
	
	// 동일한 내용의 객체 중복을 막기 위해 equals()와 hashCode()의 오버라이딩이 필요하다.
	public boolean equals(Object obj) {
		if(!(obj instanceof Person)) {
			return false;
		}
		Person p = (Person)obj;
		// 나 자신(this)의 이름과 나이를 p와 비교
		return name.equals(p.name) && age == p.age;
	}
	
	public int hashCode() {
		// int hash(Object... values); -> '...' 가변인자(객체를 구분하는 기준을 넣어주면 된다.)
		return Objects.hash(name, age);
	}
}

출력:
오버라이딩 전 -> [David:10, abc, David:10]
오버라이딩 후 -> [David:10, abc]
```
```
import java.util.HashSet;
import java.util.Iterator;

class Ex11_12 {
	public static void main(String[] args) {
		HashSet setA = new HashSet();
		HashSet setB = new HashSet();
		HashSet setHab = new HashSet();
		HashSet setKyo = new HashSet();
		HashSet setCha = new HashSet();
		
		setA.add("1"); setA.add("2"); setA.add("3");
		setA.add("4"); setA.add("5");
		System.out.println("A = "+setA);
		
		setB.add("4"); setB.add("5"); setB.add("6");
		setB.add("7"); setB.add("8");
		System.out.println("B = "+setB);
	
		Iterator it = setB.iterator();
		while(it.hasNext()) {
			Object tmp = it.next();
			if(setA.contains(tmp)) {
				setKyo.add(tmp);
			}
		}
		
		it = setA.iterator();
		while(it.hasNext()) {
			Object tmp = it.next();
			if(!setB.contains(tmp)) {
				setCha.add(tmp);
			}
		}
		
		it = setA.iterator();
		while(it.hasNext()) {
			setHab.add(it.next());
		}
		
		it = setB.iterator();
		while(it.hasNext()) {
			setHab.add(it.next());
		}
		
		System.out.println("A와 B의 교집합 : "+setKyo);
		System.out.println("A와 B의 합집합 : "+setHab);
		System.out.println("A와 B의 차집합 : "+setCha);
	}
}
```

**TreeSet**
- 이진 탐색 트리(binary search tree)로 구현. 범위 탐색과 정렬에 유리
- 이진 트리는 모든 노드가 최대 2개의 하위 노드를 갖는다.
- 각 요소(node)가 나무(tree) 형태로 연결(LinkedList의 변형)
- HashSet보다 데이터 추가, 삭제에 시간이 더 걸림
![TreeSet](TreeSet.png)  

**이진 탑색 트리(binary search tree)**
- 부모보다 작은 값은 왼쪽, 큰 값은 오른쪽에 저장
- 데이터가 많아질 수록 추가, 삭제에 시간이 더 걸림(비교 횟수 증가)

**TreeSet 데이터 저장과정**
- boolean add(Object o) 사용
	1. equals(), hashcode() 호출 : 중복을 허용하지 않으므로 같은게 있는지 비교
- 루트부터 트리를 따라 내려가며 값을 비교. 작으면 왼쪽, 크면 오른쪽에 저장
![TreeSet데이터저장과정](TreeSet데이터저장과정.png)  

**TreeSet 주요 생성자와 메서드**
![TreeSet생성자와메서드](TreeSet생성자와메서드.png)  
```
import java.util.Set;
import java.util.TreeSet;

class Ex11_13 {
	public static void main(String[] args) {
		Set set = new TreeSet();
		
		for(int i = 0; set.size() < 6; i++) {
			int num = (int)(Math.random()*45)+1;
			set.add(num);
		}
		System.out.println(set); // [1, 12, 19, 37, 39, 40] 정렬이 된 채로 출력

	}
}
```
```
import java.util.TreeSet;

class Ex11_15 {
	public static void main(String[] args) {
		TreeSet set = new TreeSet();
		int[] score = {80,95,50,35,45,65,10,100};
		
		for(int i = 0; i < score.length;i++) {
			set.add(new Integer(score[i]));
		}
		
		System.out.println("50보다 작은 값 : "+set.headSet(50)); // 
		System.out.println("50보다 큰 값 : "+set.tailSet(new Integer(50)));
	}
}

출력 : 
50보다 작은 값 : [10, 35, 45]
50보다 큰 값 : [50, 65, 80, 95, 100]
```
![TreeSet범위검색](TreeSet범위검색.png)  

**HashMap과 Hashtable**
- 순서 X, 중복(키 X, 값 O)
- Map 인터페이스를 구현. 데이터를 키와 값의 쌍으로 저장
- HashMap(동기화X)은 Hashtable(동기화O)의 신버전
- HashMap
	- Map 인터페이스를 구현한 대표적인 컬렉션 클래스
	- 순서를 유지하려면, LinkedHashMap클래스를 사용하면 된다.
- TreeMap
	- 범위 검색과 정렬에 유리한 컬렉션 클래스
	- HashMap보다 데이터 추가, 삭제에 시간이 더 걸린다.

**HashMap의 키(key)와 값(value)**
- 해싱(hashing)기법으로 데이터를 저장. 데이터가 많아도 검색이 빠르다.
- Map인터페이스를 구현. 데이터를 키와 값의 쌍으로 저장
	- 키(key) : 컬렉션 내의 키(key) 중에서 유일해야 한다. (중복 X)
	- 값(value) : 키(key)와 달리 데이터 중복을 허용한다. (중복 O)

**해싱(hashing)**
- 해시함수(hash function)로 해시테이블(hash table)에 데이터를 저장, 검색
![hashing1](hashing1.png)  
- 해시테이블은 배열과 링크드 리스트가 조합된 형태
![hashing2](hashing2.png)  
- 해시테이블에 저장된 데이터를 가져오는 과정
![hashing3](hashing3.png)  
	1. 키로 해시함수를 호출해서 해시코드를 얻는다.
	2. 해시코드(해시함수의 반환값)에 ㅎ대응하는 링크드리스트를 배열에서 찾는다.
	3. 링크드리스트에서 키와 일치하는 데이터를 찾는다.
- 해시함수는 같은 키에 대해 항상 같은 해시코드를 반환해야 한다.
- 서로 다른 키일지라도 같은 값의 해시코드를 반환할 수 있다.

**HashMap 주요 메서드**
![HashMap주요메서드](HashMap주요메서드.png)  

```
import java.util.HashMap;
import java.util.Scanner;

class Ex11_16 {
	public static void main(String[] args) {
		HashMap map = new HashMap();
		map.put("myId",  "1234");
		map.put("asdf", "1111");
		map.put("asdf", "1234");
		
		Scanner s = new Scanner(System.in);
		
		while(true) {
			System.out.println("id와 password를 입력해주세요.");
			System.out.print("id : ");
			String id = s.nextLine().trim();
			
			System.out.print("password : ");
			String pw = s.nextLine().trim();
			System.out.println();
			
			if(!map.containsKey(id)) {
				System.out.println("입력하신 id는 존재하지 않습니다. 다시 입력해주세요.");
				continue;
			}
			
			if(!(map.get(id)).equals(pw)){
				System.out.println("비밀번호가 일치하지 않습니다. 다시 입력해주세요.");
			} else {
				System.out.println("id와 password가 일치합니다.");
				break;
			}
		}
	}
}
```
```
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

class Ex11_17 {
	public static void main(String[] args) {
		HashMap map = new HashMap();
		map.put("김자바", 90);
		map.put("김자바", 100); // key값이 일치하므로 value값이 덮어써짐
		map.put("이자바", 100);
		map.put("최자바", 80);
		map.put("안자바", 90);
		
		Set set = map.entrySet();
		Iterator it = set.iterator();
		
		while(it.hasNext()) {
			// Map 인터페이스 내부의 Entry 인터페이스를 통해 entry 지정
			Map.Entry e = (Map.Entry)it.next();
			System.out.println("이름 : "+e.getKey()+", 점수 : "+e.getValue());
		}
		
		set = map.keySet(); // 
		System.out.println("참가자 명단 : "+set);
		
		Collection values = map.values(); // Collection values() 로 반환값이 Collection.
		it = values.iterator();
		
		int total = 0;
		
		while(it.hasNext()) {
			int i = (int)it.next();
			total += i;
		}
		
		System.out.println("총점 : "+total);
		System.out.println("평균 : "+(float)total/set.size());
		// Comparable 구현 객체만 max,min 변수로 넣을 수 있다.
		System.out.println("최고점수 : "+Collections.max(values));
		System.out.println("최저점수 : "+Collections.min(values));
	}
}
```
```
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

class Ex11_18 {
	public static void main(String[] args) {
		String[] data = {"A","K","Z","K","D","K","Z","A","K","Z","A","K"};
		
		HashMap map = new HashMap();
		
		for(int i = 0; i < data.length; i++) {
			if(map.containsKey(data[i])) {
				int value = (int)map.get(data[i]);
				map.put(data[i], value +1);
			} else {
				map.put(data[i],1);
			}
		}
		
		Iterator it = map.entrySet().iterator();
		
		while(it.hasNext()){
			Map.Entry entry = (Map.Entry)it.next();
			int value = (int)entry.getValue();
			System.out.println(entry.getKey()+" : "+printBar('#',value)+" "+value);
		}
	}
	
	static String printBar(char ch, int value) {
		char[] bar = new char[value];
		
		for(int i = 0; i < bar.length; i++) {
			bar[i] = ch;
		}
		
		return new String(bar); // String(char[] chArr)
	}
}

출력 : 
A : ### 3
D : # 1
Z : ### 3
K : ##### 5
```

**Collections**
- 컬렉션을 위한 메서드(static)를 제공
1. 컬렉션 채우기, 복사, 정렬, 검색 -> fill(), copy(), sort(), binarySearch() 등
2. 컬렉션의 동기화 -> synchronizedXXX()
```
static Collection synchronizedCollection(Collection c)
static List synchronizedList(List list)
static Set synchronizedSet(Set s)
static Map synchronizedMap(Map m)
static SortedSet synchronizedSortedSet(SortedSet s)
static SortedMap synchronizedSortedMap(SortedMap m)
```
3. 변경불가(readOnly) 컬렉션 만들기 -> unmodifiableXXX()
```
static Collection unmodifiableCollection(Collection c)
static List unmodifiabledList(List list)
static Set unmodifiableSet(Set s)
static Map unmodifiableMap(Map m)
static NavigableSet unmodifiableNavigabledSet(NavigableSet s)
static SortedSet unmodifiableSrotedSet(SortedSet s)
static NavigableMap unmodifiableNavigableMap(NavigableMap m)
static SortedMap unmodifiableSortedMap(SortedMap m)
```
4. 싱글톤 컬렉션 만들기 -> singletonXXX()
```
static List singletonList(Object o)
static Set singleton(Object o) // singletonSet 이 아님에 주의
static Map singletonMap(Object key, Object value)
```
5. 한 종류의 객체만 저장하는 컬렉션 만들기 -> checkedXXX()
```
static Collection checkedCollection(Collection c, Class type)
static List checkedList(List list, Class type)
static Set checkedSet(Set s, Class type)
static Map checkedMap(Map m, Class keyType, Class valueType)
static Queue checkedQueue(Queue queue, Class type)
static NavigableSet checkedNavigableSet(NavigableSet s, Class type)
static SortedSet checkedSortedSet(SortedSet s, Class type)
static NavigableMap checkedNavigableMap(NavigableMap m, Class keyType, Class valueType)
static SortedMap checkedSortedMap(SortedMap m, Class keyType, Class valueType)
```

```
import java.util.*;
import static java.util.Collections.*;

class Ex11_19 {
	public static void main(String[] args) {
		List list = new ArrayList(); // list 생성
		System.out.println(list); // []
		
		addAll(list, 1,2,3,4,5); // list에 객체 추가
		System.out.println(list); // [1, 2, 3, 4, 5]
		
		rotate(list, 2); // 오른쪽으로 두 칸씩 이동
		System.out.println(list); // [4, 5, 1, 2, 3]
		
		swap(list,0,2); // 첫 번째와 세 번째를 교환(swap)
		System.out.println(list); // [1, 5, 4, 2, 3]
		
		shuffle(list); // 저장된 요소의 위치를 임의로 변경
		System.out.println(list); // [3, 1, 5, 2, 4]
	
		sort(list, reverseOrder()); // 역순 정렬 reverse(list);와 동일
		System.out.println(list); //[5, 4, 3, 2, 1]
				
		sort(list); // 정렬
		System.out.println(list); // [1, 2, 3, 4, 5]
		
		int idx = binarySearch(list, 3); // 3이 저장된 index 반환(정렬 후에 찾을 것!)
		System.out.println("index of 3 = "+idx); // index of 3 = 2
		
		System.out.println("max = "+max(list)); // max = 5
		System.out.println("min = "+min(list)); // min = 1
		System.out.println("min = "+max(list,reverseOrder())); // min = 1
		
		fill(list,9); // list를 9로 채운다
		System.out.println("list = "+list); // list = [9, 9, 9, 9, 9]
		
		// list와 같은 크기의 새로운 list를 생성하고 2로 채운다. 단, 결과는 변경 불가
		List newList = nCopies(list.size(), 2); 
		System.out.println("newList = "+newList); // nuwList = [2, 2, 2, 2, 2]
		
		System.out.println(disjoint(list,newList)); // 공통 요소가 없으면 true
		
		copy(list,newList);
		System.out.println("newList = "+newList); // newList = [2, 2, 2, 2, 2]
		System.out.println("list = "+list); // list = [2, 2, 2, 2, 2]
		
		replaceAll(list,2,1);
		System.out.println("list = "+list); // list = [1, 1, 1, 1, 1]
		
		Enumeration e = enumeration(list);
		ArrayList list2 = list(e);
		
		System.out.println("list2 = "+list2); // list2 = [1, 1, 1, 1, 1]
		
	}
}
```

### **Ch12. 지네릭스, 열거형, 애너테이션**

**지네릭스(Generics)**
- 컴파일 시 타입을 체크해 주는 기능(compile-time type check)(JDK1.5)
- 객체의 타입 안정성을 높이고 형변환의 번거로움을 줄여줌
```
// Tv객체만 저장할 수 있는 ArrayList를 생성
ArrayList<Tv> tvList = new ArrayList<Tv>();

tvList.add(new Tv()); // OK
tvList.add(new Audio()); // 컴파일 에러. Tv 외 다른 타입 저장 불가
```

**타입 변수**
- 클래스를 작성할 때, Object 타입 대신 타입 변수(T)를 선언해서 사용.
![타입변수](타입변수.png)  
- 객체를 생성 시, 타입 변수(T) 대신 실제 타입을 지정(대입)
- 타입 변수 대신 실제 타입이 지정되면, 형변환 생략 가능
```
// No 지네릭스
ArrayList tvList = new ArrayList();
tvList.add(new Tv());
Tv t = (Tv)tvList.get(0);
```
```
// 지네릭스(타입변수)
ArrayList<Tv> tvList = new ArrayList<Tv>();
tvList.add(new Tv());
Tv t = tvList.get(0); // 형변환 불필요
```

**지네릭스 용어**
![지네릭스용어](지네릭스용어.png)  
- Box<T> : 지네릭 클래스. T의 Box 또는 T Box라고 읽는다.
- T : 타입 변수 또는 타입 매개변수.(T는 타입 문자)
- Box : 원시 타입(raw type)

**지네릭 타입과 다형성**
- 참조 변수와 생성자의 대입된 타입은 일치해야 한다.
```
ArrayList<Tv> list = new ArrayList<Tv>();      // OK. 일치
ArrayList<Product> list = new ArrayList<Tv>(); // 에러. 불일치
```
- 지네릭 클래스 간의 다형성은 성릭.(여전히 대입된 타입은 일치해야)
```
List<Tv> list = new ArrayList<Tv>();
List<Tv> list = new LinkedList<Tv>();
```
- 매개변수의 다형성도 성립.
```
ArrayList<Product> list = newArrayList<Product>();
list.add(new Product());
list.add(new Tv());
list.add(new Audio());
```
- 대신, ArrayList에 저장된 객체를 꺼낼 때, 형변환 필요
```
Product p = list.get(0); // Product 객체는 형변환이 필요없다.
Tv t = (Tv)list.get(1); // Product의 자손객체들은 형변환을 필요로 한다.
```
```
import java.util.ArrayList;
import java.util.List;

public class Ex12_1 {
	public static void main(String[] args) {
		ArrayList<Product> productList = new ArrayList<Product>();
		ArrayList<Tv> tvList = new ArrayList<Tv>();
		ArrayList<Product> tvList2 = new ArrayList<Tv>(); // 에러.
		List<Tv> tvList3 = new ArrayList<Tv>(); // OK. 다형성
		
		productList.add(new Tv());
		productList.add(new Audio());
		
		tvList.add(new Tv());
		
		printAll(productList);
		printAll(tvList); // 컴파일 에러 발생
	}
	
	public static void printAll(ArrayList<Product> list){
		for(Product p : list) {
			System.out.println(p);
		}
	}
}

class Product {}
class Tv extends Product {}
class Audio extends Product {}
```

**Iterator<E>**
- 클래스를 작성할 때, Object타입 대신 E와 같은 타입 변수를 사용
```
public interface Iterator<E> {
	boolean hasNext();
	E next();
	void remove();
}
```
```
import java.util.ArrayList;
import java.util.Iterator;

public class Ex12_2 {
	public static void main(String[] args) {
		ArrayList<Student> list = new ArrayList<Student>();
		
		list.add(new Student("자바왕",1,1));
		list.add(new Student("자바짱",1,2));
		list.add(new Student("자바킹",2,1));
		
		Iterator<Student> it = list.iterator();
		
		while(it.hasNext()) {
			// Student s = (Student)it.next(); // 지네릭스를 사용하지 않으면 형변환 필요
			Student s = it.next();
			System.out.println(s.name);
		}
	}
}

class Student {
	String name = "";
	int ban;
	int no;
	
	Student(String name, int ban, int no){
		this.name = name;
		this.ban = ban;
		this.no = no;
	}
}
```

**HashMap<K,V>**
- 여러 개의 타입 변수가 필요한 경우, 콤마','를 구분자로 선언
```
public class HashMap<K,V> extends AbstractMap<K,V> { // 일부 생략
	...
	public V get(Object key) {/* 내용 생략 */}
	public V put(K key, V value) {/* 내용 생략 */}
	public V remove(Object key) {/* 내용 생략 */}
	...
}
```
```
import java.util.HashMap;

public class Ex12_2_2 {
	public static void main(String[] args) {
		HashMap<String, Student> map = new HashMap<>(); // JDK1.7부터 생성자에 타입 지정 생략 가능
		map.put("자바왕", new Student("자바왕",1,1));
				
		System.out.println(map);
	} // main
}

class Student {
	String name = "";
	int ban;
	int no;
	
	public String toString() {
		return name+" "+ban+"반 no."+no;
	}
	
	Student(String name, int ban, int no){
		this.name = name;
		this.ban = ban;
		this.no = no;
	}
}
```

**제한된 지네릭 클래스**
- extends로 대입할 수 있는 타입을 제한
```
class FruitBox<T extends Fruit> { // Fruit의 자손만 타입으로 지정가능
	ArrayList<T> list = new ArrayList<T>();
	...
}

FruitBox<Apple> appleBox = new FruitBox<Apple>();
FruitBox<Toy> toyBox = new FruitBox<Toy>();
```
- 인터페이스인 경우에도 extends를 사용
```
interface Eatable {}
class FruitBox<T extends Eatable> {...}
```
```
import java.util.ArrayList;

class Ex12_3 {
	public static void main(String[] args) {
		FruitBox<Fruit> fruitBox = new FruitBox<>();
		FruitBox<Apple> appleBox = new FruitBox<>();
		FruitBox<Grape> grapeBox = new FruitBox<>();
//		FruitBox<Grape> grapeBox = new FruitBox<Apple>(); // 에러. 타입 불일치
		Box<Toy> toyBox = new Box<>();
//		FruitBox<Toy> toyBox = new FruitBox<>(); // 에러. 상속 X(제한 사항 적용 받음)
		
		fruitBox.add(new Fruit());
		fruitBox.add(new Apple());
		fruitBox.add(new Grape());
		appleBox.add(new Apple());
		grapeBox.add(new Grape());
//		appleBox.add(new Grape()); // 에러. Grape는 Apple의 자손 X
		
		System.out.println("fruitBox - "+fruitBox);
		System.out.println("appleBox - "+appleBox);
		System.out.println("grapeBox - "+grapeBox);
		
	}
}

class Fruit implements Eatable {public String toString() {return "Fruits";}}
class Apple extends Fruit {public String toString() {return "Apple";}}
class Grape extends Fruit {public String toString() {return "Grape";}}
class Toy {public String toString() {return "Toy";}}

interface Eatable {}

// 인터페이스 함께 사용 시 ','가 아닌 '&' 사용
class FruitBox<T extends Fruit & Eatable> extends Box<T> {}

class Box<T> {
	ArrayList<T> list = new ArrayList<>();
	void add(T item) {list.add(item);}
	T get(int i) {return list.get(i);}
	int size() {return list.size();}
	public String toString() {return list.toString();}
}

출력 : 
fruitBox - [Fruits, Apple, Grape]
appleBox - [Apple]
grapeBox - [Grape]
```

**지네릭스의 제약**
- 타입 변수에 대입은 인스턴스 별로 다르게 가능
```
Box<Apple> appleBox = new Box<Apple>();
Box<Grape> grapeBox = new Box<Grape>();
```
- static멤버에 타입 변수 사용 불가
```
class Box<T> {
	static T item; // 에러. 모든 인스턴스 공통이므로 특정 인스턴스 지정 불가
	static int compare(T t1, T t2) {...} // 에러.
	...
}
```
- 배열 생성할 때 타입 변수 사용 불가.(new 다음에 사용 불가)
- 타입 변수로 배열 선언은 가능.
```
class Box<T> {
	T[] itemArr; // OK. T 타입의 배열을 위한 참조변수
	...
	T[] toArray() {
		T[] tmpArr = new T[itemArr.length]; // 에러. 지네릭 배열 생성불가
		// new 연산자는 그 타입이 확정되어 있어야 한다.(new 다음 T 사용불가)
}
```
 
**와일드 카드 <?>**
- 하나의 참조 변수로 대입된 타입이 다른 객체를 참조 가능
	- <? extends T> : 와일드 카드의 상한 제한. T와 그 자손들만 가능
	- <? super T> : 와일드 카드의 하한 제한. T와 그 조상들만 가능
	- <?> : 제한 없음. 모든 타입이 가능. <? extends Object>와 동일
```
ArrayList<? extends Product> list = new ArrayList<Tv>(); // OK
ArrayList<? extends Product> list = new ArrayList<Audio>(); // OK
ArrayList<Product> list = new ArrayList<Tv>(); // 에러. 대입된 타입 불일치
```
- 메서드의 매개변수에 와일드 카드를 사용
```
import java.util.ArrayList;

class Fruit2 {public String toString() {return "Fruit";}}
class Apple2 extends Fruit2 {public String toString() {return "Apple";}}
class Grape2 extends Fruit2 {public String toString() {return "Grape";}}

class Juice {
	String name;
	
	Juice(String name) {this.name = name + "Juice";}
	public String toString() {return name;}
}

class Juicer {
	// 와일드 카드 사용하여 Fruit2와 그 자손 모두 메서드 사용 가능
	static Juice makeJuice(FruitBox2<? extends Fruit2> box) {
		String tmp = "";
		
		for(Fruit2 f : box.getList()) { // 향상된 for문
			tmp += f + " ";
		}
		return new Juice(tmp);
	}
}

public class Ex12_4 {
	public static void main(String[] args) {
		FruitBox2<Fruit2> fruitBox = new FruitBox2<Fruit2>();
		FruitBox2<Apple2> appleBox = new FruitBox2<Apple2>();
		
		fruitBox.add(new Apple2());
		fruitBox.add(new Grape2());
		appleBox.add(new Apple2());
		appleBox.add(new Apple2());
		
		System.out.println(Juicer.makeJuice(fruitBox)); // Apple Grape Juice
		System.out.println(Juicer.makeJuice(appleBox)); // Apple Apple Juice

	
	}
}

class FruitBox2<T extends Fruit2> extends Box2<T> {}

class Box2<T> {
	ArrayList<T> list = new ArrayList<T>();
	void add(T item) {list.add(item);}
	T get(int i) {return list.get(i);}
	ArrayList<T> getList() {return list;}
	int size() {return list.size();}
	public String toString() {return list.toString();}
}
```

**지네릭 메서드**
- 지네릭 타입이 선언된 메서드(타입 변수는 메서드 내에서만 유효)
```
static <T> void sort(List<T> list, Comparator<? super T> c)
```
- 클래스의 타입 매개변수 <T>와 메서드의 타입 매개변수 <T>는 별개
```
class FruitBox<T> { // 해당 타입 매개변수와 아래 타입 매개변수는 별개이다.
	...
	static <T> void sort(List<T> list, Comparator<? super T> c) {
		...
	}
}
```
- 메서드를 호출할 때마다 타입을 대입해야(대부분 생략 가능)
```
FruitBox<Fruit> fruitBox = new FruitBox<Fruit>();
FruitBox<Apple> appleBox = new FruitBox<Apple>();
...
System.out.println(Juicer.<Fruit>makeJuice(fruitBox));
System.out.println(Juicer.<Apple>makeJuice(appleBox));
```
- 메서드를 호출할 때 타입을 생략하지 않을 때는 클래스 이름 생략 불가
```
System.out.println(<Fruit>makeJuice(fruitBox)); // 에러. 클래스 이름 생략 불가
System.out.println(this.<Fruit>makeJuice(fruitBox)); // OK
System.out.println(Juicer.<Fruit>makeJuice(fruitBox)); // OK
```

