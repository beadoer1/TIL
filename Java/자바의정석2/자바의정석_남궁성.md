# **자바의 정석 기초편 정리(10장~16장)**

**책과 강의를 참고하여 Keyword 중심으로 정리 해보려 합니다.**  
※ 정리 내용은 [자바의 정석 - 기초편 2권] 강의, 책 등을 참고하였습니다.

[Ch.10 날짜와 시간 & 형식화](#Ch10-날짜와-시간-형식화)  

---------

### **Ch10. 날짜와 시간 & 형식화**

**날짜와 시간**
- java.util.Date
	- 날짜와 시간을 다룰 목적으로 만들어진 클래스(JDK1.0~)
	- Date의 메서드는 거의 deprecated 되었지만, 여전히 쓰이고 있다.
- java.util.Calendar
	- Date클래스를 개선한 새로운 클래스(JDK1.1). 여전히 단점 존재
- java.time 패키지
	- Date와 Calendar의 단점을 개선한 새로운 클래스들을 제공(JDK1.8)
	- 기초편에서는 다루지 않는다.(자바의 정석 3판 참고할 것)

**Calendar 클래스**
- 추상 클래스이므로 getInstance()를 통해 구현된 객체를 얻어야 한다.
```
Calendar cal = new Calendar(); // 에러!! 추상 클래스는 인스턴스를 생성할 수 없다.

//OK, getInstance() 메서드는 Calendar 클래스를 구현한 클래스의 인스턴스를 반환한다.
Calendar cal = Calendar.getInstance();
```
- get()으로 날짜와 시간 필드 가져오기 -> int get(int field)
```
Calendar cal = Calendar.getInstance();  // 현재 날짜와 시간으로 셋팅됨
int thisYear = cal.get(Calendar.YEAR);  // 올해가 몇년인지 알아낸다.
int lastDayOfMonth = cal.getActualMaximum(Calendar.DATE); // 이 달의 마지막 달
```
- Calendar 에 정의된 필드
![Calendar정의된필드](Calendar정의된필드.png)  
```
import java.util.Calendar;

class Ex10_1 {
	public static void main(String[] args) {
		// 기본적으로 현재 날짜와 시간으로 설정된다.
		Calendar today = Calendar.getInstance();
		System.out.println("이 해의 년도 : " + today.get(Calendar.YEAR));
		System.out.println("월(0~11, 0:1월): " + today.get(Calendar.MONTH));
		System.out.println("이 해의 몇 째 주 : " + today.get(Calendar.WEEK_OF_YEAR));
		System.out.println("이 달의 몇 째 주 : " + today.get(Calendar.WEEK_OF_MONTH));
		
		// DATE와 DAY_OF_MONTH 는 같다.
		System.out.println("이 달의 몇 일 : " + today.get(Calendar.DATE));
		System.out.println("이 달의 몇 일 : " + today.get(Calendar.DAY_OF_MONTH));
		System.out.println("이 해의 몇 일 : " + today.get(Calendar.DAY_OF_YEAR));
		System.out.println("요일(1~7, 1: 일요일): " + today.get(Calendar.DAY_OF_WEEK));
		System.out.println("이 달의 몇 째 요일 : " + today.get(Calendar.DAY_OF_WEEK_IN_MONTH));
		System.out.println("오전_오후(0:오전, 1:오후) : " + today.get(Calendar.AM_PM));
		System.out.println("시간(0~11) : " + today.get(Calendar.HOUR));
		System.out.println("시간(0~23) : " + today.get(Calendar.HOUR_OF_DAY));
		System.out.println("분(0~59) : " + today.get(Calendar.MINUTE));
		System.out.println("초(0~59) : " + today.get(Calendar.SECOND));
		System.out.println("1000분의 1초(0~999) : " + today.get(Calendar.MILLISECOND));
		
		// 천분의 1초를 시간으로 표시하기 위해 3600000으로 나누었다.(1시간 = 60*60초)
		System.out.println("TimeZone(-12~+12): " + today.get(Calendar.ZONE_OFFSET/3600000));
		System.out.println("이 달의 마지막 날 : " + today.getActualMaximum(Calendar.DATE));
	}
}

출력 : 
이 해의 년도 : 2021
월(0~11, 0:1월): 1
이 해의 몇 째 주 : 6
이 달의 몇 째 주 : 1
이 달의 몇 일 : 5
이 달의 몇 일 : 5
이 해의 몇 일 : 36
요일(1~7, 1: 일요일): 6
이 달의 몇 째 요일 : 1
오전_오후(0:오전, 1:오후) : 1
시간(0~11) : 5
시간(0~23) : 17
분(0~59) : 16
초(0~59) : 51
1000분의 1초(0~999) : 997
TimeZone(-12~+12): 1
이 달의 마지막 날 : 28
```
- set()으로 날짜와 시간 지정하기
```
void set(int field, int value)
void set(int year, int month, int date)
void set(int year, int month, int date, int hourIfDay, int minute)
void set(int year, int month, int date, int hourOfDay, int minute, int second)
```
- 날짜 지정하는 방법. 월(MONTH)이 0부터 시작한다는 점 주의!!
```
Calendar date1 = Calendar.getInstance();
date1.set(2017,7,15); // 2017년 8월 15일(7월 아님)
// date1.set(Calendar.YEAR, 2017);
// date1.set(Calendar.MONTH, 7);
// date1.set(Calendar.DATE, 15);
```
```
import java.util.*;

class Ex10_2 {
	public static void main(String[] args) {
		//요일은 1부터 시작하기 때문에, DAY_OF_WEEK[0]은 비워둠
		final String[] DAY_OF_WEEK = {"","일","월","화","수","목","금","토"};
		
		Calendar date1 = Calendar.getInstance();
		Calendar date2 = Calendar.getInstance();
		
		// month의 경우 0부터 시작하기 때문에 4월인 경우, 3으로 지정해야한다.
		// date1.set(2019, Calendar.APRIL, 29); 와 같이 할 수도 있다. 
		date1.set(2019, 3, 29); // 2019년 4월 29일로 날짜를 설정한다.
		System.out.println("date1은 " + toString(date1)+ 
				DAY_OF_WEEK[date1.get(Calendar.DAY_OF_WEEK)] + "요일이고,");
		System.out.println("오늘(date2)은 " + toString(date2) + 
				DAY_OF_WEEK[date2.get(Calendar.DAY_OF_WEEK)] + "요일입니다."  );
		
		// 두 날짜 간의 차이를 얻으려면, getTimeInMillis() 천분의 일초 단위로 변환해야한다.
		long difference = (date2.getTimeInMillis() - date1.getTimeInMillis())/1000;
		System.out.println("그 날(date1)부터 지금(date2)까지 " + difference + "초가 지났습니다.");
		System.out.println("일로 환산하면 " + difference/(24*60*60) + "일이 됩니다.");
		
	}
	
	static String toString(Calendar date) {
		return date.get(Calendar.YEAR) + "년 " + (date.get(Calendar.MONTH)+1) + 
				"월 " + date.get(Calendar.DATE) + "일 ";
	}
}

출력:
date1은 2019년 4월 29일 월요일이고,
오늘(date2)은 2021년 2월 5일 금요일이다.
그 날(date1)부터 지금(date2)까지 55987200초가 지났습니다.
일로 환산하면 648일이 됩니다.
```
- 시간 지정하는 방법. 시,분,초 별도 설정 필요.
```
Calendar time1 = Calendar.getInstance();
time1.set(Calendar.HOUR_OF_DAY, 10);
time1.set(Calendar.MINUTE, 20);
time1.set(Calendar.SECOND, 30);
```
```
import java.util.Calendar;

public class Ex10_3 {
	public static void main(String[] args) {
		final int[] TIME_UNIT = {3600, 60, 1};
		final String[] TIME_UNIT_NAME = {"시간 ", "분 ", "초 "};
		
		Calendar time1 = Calendar.getInstance();
		Calendar time2 = Calendar.getInstance();
		
		// time1의 시간을 10시 20분 30초로 설정
		timeSet(time1,10,20,30);
		// time2의 시간을 20시 30분 10초로 설정
		timeSet(time2,20,30,10);
		
		System.out.println("time1 : "+timeToString(time1));
		System.out.println("time2 : "+timeToString(time2));
		
		long difference = 
				Math.abs(time2.getTimeInMillis()-time1.getTimeInMillis())/1000;
		System.out.println("time1과 time2의 차이는 "+difference+"초 입니다.");
		
		String tmp = "";
		// 거스름돈 구하는 알고리즘과 유사함(큰 단위부터 나눠준다.)
		for(int i = 0; i < TIME_UNIT.length; i++) {
			tmp += difference/TIME_UNIT[i] + TIME_UNIT_NAME[i];
			difference %= TIME_UNIT[i];
		}
		System.out.println("시분초로 환산하면, "+tmp+"입니다.");
	}
	
	static void timeSet(Calendar date, int hour, int min, int sec) {
		date.set(Calendar.HOUR_OF_DAY, hour);
		date.set(Calendar.MINUTE, min);
		date.set(Calendar.SECOND, sec);
	}
	
	static String timeToString(Calendar date) {
		return date.get(Calendar.HOUR_OF_DAY)+"시 "+date.
				get(Calendar.MINUTE)+"분 "+date.get(Calendar.SECOND)+"초 ";
	}
}

출력:
time1 : 10시 20분 30초 
time2 : 20시 30분 10초 
time1과 time2의 차이는 36580초 입니다.
시분초로 환산하면, 10시간 9분 40초 입니다.
```
- clear()는 Calendar 객체의 모든 필드를 초기화
- 날짜 및 시간을 설정하기 전에 clear()를 통해 초기화를 해주는 것이 좋다.
```
Calendar dt = Calendar.getInstance();

// Fri Feb 05 19:05:59 KST 2021
System.out.println(new Date(dt.getTimeInMillis()));

dt.clear();
// Thu Jan 01 00:00:00 KST 2017 <- EPOCH Time
System.out.println(new Date(dt.getTimeInMillis()));
```
- clear(int field)는 Calendar 객체의 특정 필드를 초기화
```
Calendar dt = Calendar.getInstance();

// Fri Feb 05 19:05:59 KST 2021
System.out.println(new Date(dt.getTimeInMillis()));

dt.clear(Calendar.SECOND);
dt.clear(Calendar.MINUTE);
dt.clear(Calendar.HOUR_OF_DAY);
dt.clear(Calendar.HOUR);

// Fri Feb 05 00:00:00 KST 2021
System.out.println(new Date(dt.getTimeInMillis()));
```
- add() 는 특정 필드의 값을 증가 또는 감소(다른 필드에 영향O)
```
Calendar date = Calendar.getInstance();
date.clear(); // 모든 필드를 초기화
date.set(2020,7,31); // 2020년 8월 31일로 설정

date.add(Calendar.DATE, 1); // 날짜(DATE)에 1을 더한다. -> 9월 1일로 변경
date.add(Calendar.MONTH, -8); // 월(MONTH)에서 8을 뺀다.
```
- roll()은 특정필드의 값을 증가 또는 감소(다른 필드에 영향X)
```
date.set(2020,7,31); // 2020년 8월 31일로 설정

// add()와 달리 roll()은 다른 필드에 영향을 미치지 않는다.
date.roll(Calendar.DATE, 1); // 날짜(DATE)에 1을 더한다. -> 8월 1일로 변경
date.roll(Calendar.MONTH, -8); // 월(MONTH)에서 8을 뺀다.
```
```
import java.util.Calendar;

class Ex10_4 {
	public static void main(String[] args) {
		Calendar date = Calendar.getInstance();
		date.set(2019, 7, 31); // 2019년 8월 31일
		
		System.out.println(toString(date));
		System.out.println("= 1일 후 =");
		date.add(Calendar.DATE, 1);
		System.out.println(toString(date));
		
		System.out.println("= 6달 전 =");
		date.add(Calendar.MONTH, -6);
		System.out.println(toString(date));
		
		// add()와 달리 roll()은 다른 필드에 영향을 주지 않는다.
		System.out.println("= 31일 후(roll) =");
		date.roll(Calendar.DATE, 31);
		System.out.println(toString(date));
		
		System.out.println("= 31일 후(add) =");
		date.add(Calendar.DATE, 31);
		System.out.println(toString(date));
		
	}
	
	static String toString(Calendar date) {
		return date.get(Calendar.YEAR)+"년 "+(date.get(Calendar.MONTH)+1)+"월 "+
			date.get(Calendar.DATE)+"일 ";
	}
}

출력 :
2019년 8월 31일 
= 1일 후 =
2019년 9월 1일 
= 6달 전 =
2019년 3월 1일 
= 31일 후(roll) =
2019년 3월 1일 
= 31일 후(add) =
2019년 4월 1일 
```

**Date와 Calendar 간의 변환**
- Date의 메서드는 대부분 deprecated 되었지만 여전히 사용
- Calendar를 Date로 변환
```
Calendar cal = Calendar.getInstance();
...
Date d = new Date(cal.getTimeInMillis()); // Date(long date)
```
- Date를 Calendar로 변환
```
Date d = new Date();
...
Calendar cal = Calendar.getInstance();
cal.setTime(d)
```

**형식화 클래스**
- java.text패키지의 DecimalFormat, SimpleDateFormat
- 숫자와 날짜를 원하는 형식으로 쉽게 출력 가능(숫자, 날짜 -> 형식 문자열)
```
double number = 1234567.89;
DecimalFormat df = new DecimalFormat("#.#E0");
String result = df.format(number); // result = "1.2E6"
```
- 형식 문자열에서 숫자와 날짜를 뽑아내는 기능(형식 문자열 -> 숫자, 날짜)
```
DecimalFormat df = new DecimalFormat("#,###.##");
Number num = df.parse("1,234,567.89");
double d = num.doubleValue(); // 1234567.89
```

**DecimalFormat**
- 숫자를 형식화할 때 사용(숫자 -> 형식 문자열)
- 특정 형식의 문자열을 숫자로 변환할 때도 사용(형식 문자열 -> 숫자)
- 참고. Integer.parseInt()와 같은 형태의 메서드는 콤마','가 포함된 문자열을 숫자로 변환 못함
![DecimalFormat](DecimalFormat.png)  

**SimpleDateFormat**
- 날짜와 시간을 다양한 형식으로 출력할 수 있게 해준다.
```
Date today = new Date();
SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd");

// 오늘 날짜를 yyyy-MM-dd 형태로 변환하여 반환
String result = df.format(today);
```
- 특정 형식으로 되어있는 문자열에서 날짜와 시간을 뽑아낼 수도 있다.
```
DateFormat df = new SimpleDateFormat("yyyy년 MM월 dd일");
DateFormat d2 = new StimplDateFormat(yyyy/MM/dd);

Date d = df.parse("2015년 11월 23일");
String result = df2.format(d);
```
![SimpleDateFormat](SimpleDateFormat.png)  

### **컬렉션 프레임웍(collectioins framework)**

**컬렉션 프레임웍**
- 컬렉션(collection) : 여러 객체(데이터)를 모아 놓은 것을 의미
- 프레임웍(framework) : 표준화, 정형화된 체계적인 프로그래밍 방식
	- 생산성이 올라가고, 유지보수가 용이해진다.
- 컬렉션 프레임웍(collections framework)
	- 컬렉션(다수의 객체)을 다루기 위한 표준화된 프로그래밍 방식)
	- 컬렉션을 쉽고 편리하게 다룰 수 있는 다양한 클래스를 제공
	- java.util 패키지에 포함. JDK1.2부터 제공
- 컬렉션 클래스(collection class)
	- 다수의 데이터를 저장할 수 있는 클래스(예, Vector, ArrayList,HashSet)

**컬렉션 프레임웍의 핵심 인터페이스**
![컬렉션프레임웍인터페이스](컬렉션프레임웍인터페이스.png)
 
**Collection 인터페이스의 메서드**
![Collection인터페이스메서드](Collection인터페이스메서드.png)

**List 인터페이스 - 순서O, 중복O**
![List인터페이스](List인터페이스.png)  
![List인터페이스메서드](List인터페이스메서드.png)  

**Set 인터페이스 - 순서X, 중복X**
![Set인터페이스](Set인터페이스.png)  
- Set 인터페이스의 메서드는 Collection 인터페이스와 동일  
![Set인터페이스메서드](Set인터페이스메서드.png)  
- 집합과 관련된 메서드(Collection에 변화가 있으면 true, 아니면 false 반환  
![Set인터페이스집합메서드](Set인터페이스집합메서드.png)  

**Map 인터페이스 - 순서X, 중복(키X,값O)**
![Map인터페이스](Map인터페이스.png)  
![Map인터페이스메서드](Map인터페이스메서드.png)  

**ArrayList**
- ArrayList는 기존의 Vector를 개선한 것으로 구현 원리와 기능적으로 동일
- ArrayList와 달리 Vector는 자체적으로 동기화처리가 되어 있다.
- List인터페이스를 구현하므로, 저장순서가 유지되고 중복을 허용한다.
- 데이터의 저장공간으로 배열을 사용한다.(배열기반)
```
public class Vector extends AbstractList
	implements List, RandomAccess, Cloneable, java.io.Serializable {
	...
	protected Object[] elementData; // 모든 종류의 객체 저장 가능
	...
```

**ArrayList의 메서드**
![ArrayList메서드](ArrayList메서드.png)  
```
import java.util.ArrayList;
import java.util.Collections;

class Ex11_1 {
	public static void main(String[] args) {
		// 기본 길이(용량, capacity)가 10인 ArrayList를 생성
		ArrayList list1 = new ArrayList(10);
		// ArrayList에는 객체만 저장 가능
		// autoboxing에 의해 기본형이 참조형으로 자동 변환
		list1.add(5); // list1.add(new Integer(5));
		list1.add(new Integer(4));
		list1.add(new Integer(2));
		list1.add(new Integer(0));
		list1.add(new Integer(1));
		list1.add(new Integer(3));
		
		ArrayList list2 = new ArrayList(list1.subList(1, 4)); // ArrayList(Collection c) 사
		print(list1, list2);
		 
		// Collection은 인터페이스, Collections는 유틸 클래스
		Collections.sort(list1);
		Collections.sort(list2);
		print(list1, list2);
		
		System.out.println("list1.containsAll(list2) : "+list1.containsAll(list2));
		
		list2.add("B");
		list2.add("c");
		list2.add(3,"a");
		print(list1, list2);
		
		list2.set(3, "AA");
		print(list1, list2);
		
		// "1"을 찾으면 index=0, 1을 찾으면 index=2
		list1.add(0, "1");
		System.out.println("index = "+list1.indexOf(1));
		
		// 입력값의 자료형을 명확히 해주어야 한다.
		list1.remove(1); // Object remove(int index) 사용
		list1.remove(new Integer(1)); // boolean remove(Object o) 사용
		list1.remove("1"); // boolean remove(Object o) 사
		print(list1,list2);
		
		// list1에서 list2와 겹치는 부분만 남기고 나머지는 삭제한다.
		System.out.println("list1.retainAll(list2) : "+list1.retainAll(list2));
		print(list1, list2);
		
		// list2에서 list1에 포함된 객체들을 삭제한다.
		for(int i = list2.size()-1;i >=0; i--) {
			if(list1.contains(list2.get(i))) {
				list2.remove(i);
			}
		} 
		print(list1, list2);
	} // main의 끝
	
	static void print(ArrayList list1, ArrayList list2) {
		System.out.println("list1 : "+ list1);
		System.out.println("list2 : "+ list2);
		System.out.println();
	}
}

출력 :
list1 : [5, 4, 2, 0, 1, 3]
list2 : [4, 2, 0]

list1 : [0, 1, 2, 3, 4, 5]
list2 : [0, 2, 4]

list1.containsAll(list2) : true
list1 : [0, 1, 2, 3, 4, 5]
list2 : [0, 2, 4, a, B, c]

list1 : [0, 1, 2, 3, 4, 5]
list2 : [0, 2, 4, AA, B, c]

index = 2
list1 : [2, 3, 4, 5]
list2 : [0, 2, 4, AA, B, c]

list1.retainAll(list2) : true
list1 : [2, 4]
list2 : [0, 2, 4, AA, B, c]

list1 : [2, 4]
list2 : [0, AA, B, c]
```

**ArrayList에 저장된 객체의 삭제 과정 1**
- ArrayList에 저장된 세 번째 데이터(data[2])를 삭제하는 과정. list.remove(2);를 호출
![ArrayList저장객체삭제과정1](ArrayList저장객체삭제과정1.png)  

**ArrayList에 저장된 객체의 삭제 과정 2**
![ArrayList저장객체삭제과정2](ArrayList저장객체삭제과정2.png)  

**배열의 장단점**
- 장점 : 배열은 구조가 간단하고 데이터를 읽는데 걸리는 시간(접근시간, access time)이 짧다.
- 단점1 : 크기를 변경할 수 없다.
	- 크기를 변경해야 하는 경우 새로운 배열을 생성 후 데이터를 복사해야 함.
	- 크기 변경을 피하기 위해 충분히 큰 배열을 생성하면, 메모리가 낭비됨.
- 단점2 : 비순차적인 데이터의 추가, 삭제에 시간이 많이 걸린다.
	- 데이터를 추가하거나 삭제하기 위해, 다른 데이터를 옮겨야 함.
	- 그러나 순차적인 데이터 추가(끝에 추가)와 삭제(끝부터 삭제)는 빠르다.

**LinkedList - 배열의 단점을 보완**
- 배열과 달리 LinkedList는 불연속적으로 존재하는 데이터를 연결(link)
- 데이터의 삭제 : 단 한 번의 참조 변경만으로 가능
![LinkedList1](LinkedList1.png)  
- 데이터의 추가 : 한 번의 Node객체 생성과 두 번의 참조 변경만으로 가능
![LinkedList2](LinkedList2.png)  

**LinkedList - 이중 연결 리스드**
- 링크드 리스트(linked list) : 연결 리스트. 데이터 접근성이 나쁨
![링크드리스트](링크드리스트.png)  
- 더블리 링크드 리스트(doubly linked list) : 이중 연결 리스트, 접근성 향상
![더블리링크드리스트](더블리링크드리스트.png)  
- 더블리 써큘러 링크드 리스트(doubly circular linked list) : 이중 원형 연결 리스트
![더블리써큘러링크드리스트](더블리써큘러링크드리스트.png)  

**ArrayList vs. LinkedList - 성능비교**
![list성능비교](list성능비교.png)  
