## **자바의 정석 기초편 정리**
**책과 강의를 참고하여 Keyword 중심으로 정리 해보려 합니다.**  
※ 정리 내용은 [자바의 정석 - 기초편] 강의, 책 등을 참고 하였습니다.

[Ch1. 자바를 시작하기 전에](#Ch1-자바를-시작하기-전에)   
[Ch2. 변수 'Variable'](#Ch2-변수-Variable)   
[Ch3. 연산자 'Operator'](#Ch3-연산자-Operator)  
[Ch4. 조건문과 반복문](#Ch4-조건문과-반복문)  
[Ch5. 배열](#Ch5-배열)  
[Ch6. 객체지향 프로그래밍1](#Ch6-객체지향-프로그래밍1)  
[Ch7. 객체지향 프로그래밍2](#Ch7-객체지향-프로그래밍2)  
[Ch8. 예외처리](#Ch8-예외처리)  
[Ch9. java.lang 패키지와 유용한 클래스](#Ch9-javalang-패키지와-유용한-클래스)  


-------------

### **Ch1. 자바를 시작하기 전에**

**Java**
- 프로그래밍 언어
- 실행환경(JRE) + 개발도구(JDK) + 라이브러리(API)  
※ Web App 개발 시 - Spring Framework 사용한다.

**Why Java??**
- 다양한 분야에 사용된다.
- 20년 간 프로그래밍 언어 1,2위를 다투고 있다.
- 배우기 쉽고 자료가 풍부하다.(역사가 오래되었다(약 20년))
- 모던 프로그래밍 언어(객체지향 + 함수형)  
※ 빅데이터의 영향으로 Java도 함수형 언어로써 지속 발전 중이다.

**Java의 특징**
- 배우기 쉬운 객체지향 언어
- 자동 메모리 관리
- 멀티 쓰레드 작성
- 풍부한 라잉브러리로 쉽게 개발 가능
- 운영체제에 독립적이다.

**자바 가상 머신(JVM_Java Virtual Machine)**
- 자바 프로그램이 실행되는 가상 컴퓨터
- 한 번 작성하면, 어디서든 실행(Write once, Run anywhere)
![JVM실행](JVM실행.png)  
※ Java 애플리케이션은 JVM에서만 실행되므로 실행에는 반드시 JVM이 필요하며 같은 이유로 운영체제에 자유롭다.

**Build 관련 Eclipse 메뉴 설명**  
Build 란?   
- 소스파일(.java)로 부터 프로그램을 만들어 내는 전과정  
Project > Build Project  
- workspace 안에 있는 모든 프로젝트를 Build 함  
Project > Build Project  
- 현재 프로젝트를 빌드(변경된 소스 파일만 새로 컴파일)  
Project > Clean  
- 이전 빌드의 정보를 모두 삭제(모든 소스 파일은 새로 컴파일한다.)  
-> 빌드 할 때마다 그 정보를 자동 저장하는데, 그 부분을 삭제함  
Project > Build Automatically  
- 소스파일 변경 후, 저장할 때마다 자동 컴파일   

**자주 사용되는 Eclipse 단축키**
- 단축키 전체 목록 보기 : cmd + shift + L
- 폰트 크기 증가/감소 : cmd + '+, -'
- 한 줄 삭제 : cmd + D
- 행단위 복사 : opt + cmd + down(or up) 
- 멀티컬럼 편집 : opt + cmd + A (한 번에 여러줄 동시 작업 시 사용)
- 행단위 이동 : opt + up, down 
- 자동 들여쓰기 : cmd + I
- 주석 처리 : cmd + / (토글)
- 주석 처리(여러줄) : /*  */ (주의사항 : ';' 이전의 주석은 주석이 아니다.)
- 자동 완성 : ctrl + space (ex: 'sysout' 기입 후 누르면 출력 명령어 자동 완성)  
- 자동 import문 추가 : cmd + shift + O 
- 해당 클래스 보기 : F3 or cmd + 'click'
- 클래스의 멤버 목록 보기 : cmd + O 
※ 단축키 변경 : Window > Preferences > General > Keys > Binding  
※ 자동완성키 변경 : Window > Preferences > Java > Editor > Templates  
  
  
### **Ch2. 변수 'Variable'**

**변수**
- 하나의 값을 저장할 수 있는 메모리 공간
- 원래 메모리 주소는 숫자로 이루어져있으나, 사람이 기억하기 좋게 이름을 붙여놓은 것이 변수

**변수의 선언**
- 값(data)을 저장할 공간을 마련하기 위해 선언
- **변수타입** **변수이름** **;**  형태로 선언
	- int age ; //정수(int) 타입의 변수 age를 선언

**변수에 값 저장**
- '=' 는 등호가 아니라 대입의 개념
```
int age ; // 정수(int) 타입의 변수 age를 선언
age = 25 ; // 변수 age에 25를 저장
int age = 25 ; // 위의 두줄을 한 줄로 표현
```
- 변수 초기화 : 변수에 처음으로 값을 저장하는 것  
[주의사항] 지역 변수는 읽기 전에 꼭! 초기화해야 함
```
int x = 0; // 변수 x를 선언 후, 0으로 초기화
int y = 5; // 변수 y를 선언 후, 5로 초기화
int y = 5; // 변수 y를 선언 후, 5로 초기화
int x = 0, y = 5; // 위 두 줄을 한 줄로 표현
```

**변수의 타입**
- 변수의 타입은 저장할 값의 타입에 의해 결정
- 저장할 값의 타입과 일치하는 타입으로 변수를 선언
- 기본형(Primitive type): Data에 가장 기본이 되는 자료형 -> 실제 값을 저장
	- 논리형 : true와 false 중 하나의 값을 가지며, 조건식과 논리적 계산에 사용
	- 문자형 : 문자를 저장하는데 사용되며, 변수 당 하나의 문자만을 저장 가능
	- 정수형 : 정수 값을 저장하는데 사용. 주로 사용하는 것은 int와 long이며,  
		byte는 이진 데이터를 다루는데 사용되고, short는 c언어와의 호환을 위해 추가되었다.(잘 안쓰임)
	- 실수형 : 실수 값을 저장하는데 사용된다. float와 double이 있다.  
		실수형의 경우 '정밀도'를 갖는데 float의 경우 7, double의 경우 15이다.
![기본형종류크기](기본형종류크기.png)  
※ Java에서 Data를 다루는 최소단위가 1byte 이므로 1byte부터 시작  
※ Java에서는 2byte 문자체계인 유니코드(Unicode)를 사용하여 문자는 2byte부터 시작
![기본형저장범위](기본형저장범위.png)  
- 참조형(Reference type) 변수
	- 기본형을 제외한 나머지(String, System 등)
	- 메모리 주소를 저장(4byte or 8byte)
	- 참조 변수는 '객체의 주소를 저장'

**변수, 상수, 리터럴**
- 변수(variable) : 하나의 값을 저장하기 위한 공간
- 상수(constant) : 한 번만 값을 저장 가능한 변수
- 리터럴(litaral) : 그 자체로 값을 의미하는 것(아래 예시에 100, 200 등)
```
int score = 100; // 변수 score에 100이란 값을 저장
    score = 200; // score 에 저장된 값이 200으로 바뀜

final int MAX = 100; // 상수 MAX에 100이란 값을 지정
        MAX = 200; // Error 발생
```

**리터럴 타입과접두사, 접미사**
![리터럴타입과접미사](리터럴타입과접미사.png)  
- 리터럴 값의 구분을 위해 접두사, 접미사를 붙여줌
	- **정수형** 접미사 없는 경우 : int,  L : long (byte, short type 리터럴은 없다.(int 형태로 사용)
	- **실수형** f : float, d(생략가능) : double
- 접두사, 접미사는 대소문자를 구분하지 않음  
(정수형 L의 경우 소문자가 숫자 1과 혼동될 수 있어 대문자 기입하는 것이 좋다.)
```
boolean power = true;
char ch = 'A';
String str = "ABC";
byte b = 127;
byte b = 128; // Error : byte 의 경우 -128 ~ 127 의 값만 저장 가능
int i = 100; // 10진수 
int oct = 0100; // 8진수(접두사 0)
int hex = 0x100; // 16진수(접두사 0x)
int bi = 0b0101; // 2진수(접두사 0b _ 1.7 버전 신규)
long l = 10000000000L; // int 의 경우 최대값이 약 2000000000(20억)이므로 그 이상의 값 정의 시 접미사L을 붙여야 함
long l = 100; // 100의 경우 int 수용범위 내에 들어오므로 L을 붙이지 않아도 됨
float f = 3.14f; // 접미사 f 는 생략 불가
double d = 3.14d; // 접미사 d 의 경우 생략 가능
```
 
**변수와 리터럴의 타입 불일치**
- 범위가 '변수 > 리터럴' 인 경우, OK
```
//예시
int i = 'A'; // int > char
long l = 123; // long > int
double d = 3.14f // double > float
```
- 범위가 '변수 < 리터럴' 인 경우, Error
```
int i = 30_0000_0000; // int의 범위(-20억~20억)를 벗어남
long l = 3.14f; // long < float
float f = 3.14; // float < double
```
- byte, short 변수에 int 리터럴 저장 가능(단, 변수 타입 범위 이내여야 함)
```
byte b = 100; // OK, byte의 범위(-128~127) 이내
byte b = 128; // Error, byte의 범위를 벗어남
```

- 문자가 여러개로 이루어진 것을 문자열 이라고 함
- 문자열은 'String' 으로 변수를 지정해 주어야 함
- String 은 Java의 기본 class 
- class 는 'new func()' 형태로 객체를 생성하여 쓰이지만 String은 자주 쓰이기 때문에 변수지정 형태로 사용한다.
```
char ch = 'A';
char ch = 'AB'; // Error ''안에는 2개 이상의 문자를 넣을 수 없다.
String s = "ABC";
String s1 = "AB";
String s2 = new String("AB"); // 이와 같은 방식으로도 지정 가능하다.(String은 class이므로)
String s = "A";
String s = ""; // 빈 문자열_ 가능
char ch = ''; // 에러
String s1 = "A" + "B"; // "AB" '+'는 문자열 결합 기
```

**두 변수의 값 교환하기**
```
int x = 10;
int y = 20;
int tmp;

System.out.println("Before change variables..");
System.out.println("x = " + x);
System.out.println("y = " + y);
System.out.println("");		

tmp = x;
x = y;
y = tmp;

System.out.println("After change variables..");
System.out.println("x = " + x);
System.out.println("y = " + y);
System.out.println("tmp = " + tmp);
```

**형식화된 출력 - printf()**
- println()의 단점 : 출력 형식 지정불가
	- 실수의 자리수 조절불가 : 소수점 n자리만 출력 하려면??
	- 10진수로만 출력 됨 : 8, 16진수로 출력하려면??
- printf()로 출력형식 지정가능('%~'형태를 지시자 라고 함)
	- 정수를 10진수, 8진수, 16진수로 출력 가능
	- 8진수와 16진수에 접두사 붙일수 있음
	- 실수 출력을 위한 %f : 지수형식%e, 간략한 형식%g(%f와 %e 비교)
	- 지시자에 숫자를 붙이면 자리수 지정 가능

![printf지시자](printf지시자.png)

```
// 진수 표현(10, 8, 16, 2)
System.out.printf("%d", 15); // 15 10진수
System.out.printf("%o", 15); // 17 8진수
System.out.printf("%x", 15); // f 16진수
System.out.printf("%s", Integer.toBinaryString(15)); // Integer.toBinaryStrin(??) 2진수로 바꿔줌
// 8, 16진수 표현 시 앞에 0, 0x 기입법 '#'
System.out.printf("%#o", 15); // 017
System.out.printf("%#x", 15); // 0xf
System.out.printf("%#X", 15); // 0xF
// 실수 출력 방식
float f = 123.4567890f;
System.out.printf("%f", f); // 1.23456787 소수점아래 6자리
System.out.printf("%e", f); // 1.234568e+02 지수형식
System.out.printf("%g", f); // 123.457 간략한 형식  
// 자리수 지정
double d = 1.23456789;
System.out.printf("[%5d]%n", 10);     // [   10]
System.out.printf("[%5d]%n", 1234567);// [1234567] 지정한 자리수 상관없이 모두 출력
System.out.printf("[%-5d]%n", 10);    // [10   ]
System.out.printf("[%05d]%n", 10);    // [00010]
System.out.printf("d=%14.10f%n", d);  // [  1.2345678900] 앞 2칸은 공백, 뒤 2칸은 0으로 채움(10자리 표현해야하므로) 
System.out.printf("[%14.6f]%n", d);   // [      1.234568]
// 문자열 표현 방법
String url = "www.codechobo.com";
System.out.printf("[%s]%n", url);    // [www.codechobo.com]
System.out.printf("[%20s]%n", url);  // [   www.codechobo.com] 20칸에 표현하라(기본 우측 정렬)
System.out.printf("[%-20s]%n", url); // [www.codechobo.com   ] '-'를 넣어주어 좌측 정렬
System.out.printf("[%.8s]", url);    // [www.code] '.8' 8글자만 표현
```
※ 더 자세한 지시자는 'JavaAPI > Formatter'

**화면에서 입력받기 - Scanner**
- Scanner : 화면으로부터 데이터를 입력받는 기능을 제공하는 '클래스'
- Scanner 사용 방법
	1. import문 추가
	2. Scanner 객체의 생성
	3. Scanner 객체를 사용
```
import java.util._*_ // 1. import문 추가
Scanner scanner = new Scanner(System.in); // 2. Scanner객체의 생성
Scanner scanner = new Scanner(System.in); // 2. Scanner객체의 생성
int num = scanner.nextInt(); // 3. Scanner객체를 사용(화면에서 입력받은 정수를 num에 저장)
// 위의 3번 문장 풀이 ↓↓↓↓↓↓↓↓ 
String input = scanner.nextLine(); // 화면에서 입력받은 내용을 input에 저장
int num = Integer.parseInt(input); // 문자열(input)을 숫자(num)로 저장
```

**타입 간의 변환방법**
- 문자와 숫자 간의 변환
	- 숫자 -> 문자 : + '0'(숫자 0)
	- 문자 -> 숫자 : - '0'(숫자 0)
- 문자열로의 변환
	- 숫자 -> 문자열 : + "" (빈 문자열)
	- 문자 -> 문자열 : + "" (빈 문자열)
- 문자열을 숫자로 변환
	- 문자열 -> 정수 : Integer.parseInt(args) (args에 문자열 기입)
	- 문자열 -> 실수 : Double.parseDouble(args) (args에 문자열 기입)
- 문자열을 문자로 변환
	- 문자열 -> 문자 : 문자열.charAt()  ex) "3".charAt() == '3'


### **Ch3. 연산자 'Operator'**

**연산자란?**
- 연산자 : 연산을 수행하는 기호
- 피연산자 : 연산자의 연산 수행 대상
- 모든 연산자는 연산결과를 반환 -> 연산결과를 반환하지 않으면 연산자가 아니다.
```
X + 3 // '+'는 연산자, 'X','3'은 피연산자
```

**연산자의 종류**  
![연산자의종류](연산자의종류.png)

**연산자의 우선순위**
- 하나의 식(expression)에 연산자가 둘 이상 있을 때, 어떤 연산을 먼저 수행할지를 자동 결정  
![연산자우선순위](연산자우선순위.png)

**연산자의 결합규칙**
- 우선순윅 같은 연산자가 있을 때, 어떤 것을 먼저할 것인가  
![연산자결합순위](연산자결합규칙.png)
```
x = y = 3 // y = 3 부터 진행 후 x = y  진행
```

**연산자 우선순위, 결합법칙 정리**
1. 산술 > 비교 > 논리 > 대입. 대입은 가장 마지막에 수행
2. 단항(1) > 이항(2) > 삼항(3). 단항 연산자의 우선순위가 이항 연산자보다 높음
3. 단항 연산자와 대입 연산자를 제외한 모든 연산의 진행방향은 왼쪽에서 오른쪽

**증감 연산자**
- 증가 연산자(++) : 피연산자의 값을 1 증가시킨다.
- 감소 연산자(--) : 피연산자의 값을 1 감소시킨다.  
![증감연산자](증감연산자.png)  
※ 증감연산자가 독립적으로 사용된 경우, 전위형과 후위형의 차이가 없다.

**형변환 연산자**
- 형변환 : 변수 또는 상수의 타입을 다른 타입으로 변환하는 것
- '(바꿔줄타입)피연산자' 형태로 사용  
![형변환연산자](형변환연산자.png)

**자동 형변환**
- 컴파일러가 자동으로 형변환을 해주는 것
- 리터럴의 타입보다 변수의 타입이 범위가 넓을 때 이루어짐  
※ 반대로 리터럴의 타입이 더 범위가 넓을 경우 Error 발생.  
-> 직접 형변환 해주어야 함. 
```
float f = 1234; // int 타입의 값을 float타입의 변수에 저장
float f = (float)1234; // 컴파일러가 자동으로 형변환을 해줌

int i = 3.14f; // Error 발생(int < float)
int i = (int)3.14f; // OK 'i = 3' 으로 저장 
```
![자동형변환](자동형변환.png)

**산술 변환**
- 산술 변환 : 연산 전에 피연산자의 타입을 일치시키는 것 
- 투 피연산자의 타입을 같게 일치시킨다.(보다 큰 타입으로 일치)  
	long + int -> long + long -> long  
	float + int -> float + float -> float  
	double + float -> double + double -> double  
- 피연산자의 타입이 int보다 작은 타입이면 int로 변환된다.  
	byte + short -> int + int -> int  
	char + short -> int + int -> int  
```
int a = 1_000_000; // 1,000,000  1백만 = 10의 6제곱 
int b = 2_000_000; // 2,000,000  2백만 = 10의 6제곱 
// 10의 12제곱. int의 범위는 10의 9제곱 
long c = a * b; // int*int 이므로 결과값은 int로 계산된 후 long에 들어감.
long d = (long)a * b; // 둘 중 하나 값에 형변환 해주어야 둘다 바뀐 채로 계산
		
System.out.println(c); // -1454759936
System.out.println(d); // 2,000,000,000,000
```

**반올림 - Math.round()**
- 실수를 소수점 첫 째자리에서 반올림한 정수를 반환
```
double pi = 3.141592;
double shortPi = Math.round(pi*1000)/1000.0; // 소수점 첫째짜리 반올림이므로
System.out.println(shortPi); // 3.142
```

**문자열의 비교**
- 문자열 비교에는 비교연산자 '==' 대신 equals()을 사용해야 한다.
```
// 1번 예시
String str1 = 'abc';
String str2 = 'abc';
System.out.println(str1 == str2); // true
System.out.println(str1.equals(str2)); // true

// 2번 예시
String str1 = new String('abc');
String str2 = new String('abc');
System.out.println(str1 == str2); // false <- 이런 경우 때문에 equals()를 써야한다.
System.out.println(str1.equals(str2)); // true 
```

**논리 연산자 &&, || tip!**
- 문자 ch는 숫자('0'~'9')이다.
	- '0' <= ch && ch <= '9' // 단일 문자의 조건을 물어볼 때는 유니코드를 생각할 것
- 문자 ch는 대문자 또는 소문자이다.
	- ('a' <= ch && ch <= 'z') || ('A' <= ch && ch <= 'Z')

**논리 부정 연산자 !**
- true 를 false로, false 를 true로 바꾼다.  
| x | !x |
| :----: | :----: |
| true | false |
| false | true |
<br/>

```
boolean b = true;
!!b -> !!true -> !false -> true
```
- '문자 ch 가 소문자가 아니다.' 를 표시할 때  
![논리부정연산자](논리부정연산자.png)

**조건 연산자**
- 조건식의 결과에 따라 연산결과를 달리한다.
- 유일한 3항 연산자로 피연산자가 3개
![조건연산자](조건연산자.png)
```
// 예시
result = (x > y) ? x : y ;
-> result = (5 > 3) ? 5 : 3 ;
-> result = (true) ? 5 : 3 ;
-> result = 5 ;

// 간단한 조건문은 조건 연산자로..
if ( x > y )
	result = x;
else
	result = y;

-> result = (x > y) ? x : y ;
```

**대입 연산자**
- 오른쪽 피연산자를 왼쪽 피연산자에 저장 후 저장된 값을 반환
- 오른쪽에서 왼쪽으로 진행
```
System.out.println(x = 3); // 변수 x에 3이 저장되고,
-> System.out.println(3);  // 연산결과인 3이 출력
```
- lvalue : 대입 연산자의 왼쪽 피연산자
- rvalue : 대입 연산자의 오른쪽 피연산자  
![대입연산자](대입연산자.png)

**복합 대입 연산자**
- 대입 연산자와 다른 연산자를 하나로 축약  
![복합대입연산자](복합대입연산자.png)


### **Ch4. 조건문과 반복문**
- 프로그램의 실행 흐름을 바꿔준다고 하여 '제어문(flow control statement)' 이라고도 함 
**조건문(if, switch)** : 조건을 만족할 때만 {}를 수행(0번에서최대 1번)  
**반복문(while, for)** : 조건을 만족하는 동안 {}를 수행(0번에서 최대 n번)  
  
※ 조건식의 다양한 예  
![조건식의다양한예](조건식의다양한예.png)

**블럭 {}**
- 여러 문장을 하나로 묶어주는 것
- 조건문에 종속된 문장이 하나인 경우, 생략 가능
- But, 하나 이상인 경우 둘째줄부터는 조건문에 속하지 않으므로 블럭 사용하자.
```
if(score > 60)
	System.out.println("합격입니다.");    // if문에 속한 문장 처리
	System.out.println("축하 드립니다."); // if문에 속한 문장이 아님
```

**if - else if문 예제**
- 리팩토링 개념으로 else 구문을 생략하기 위해 grade 초기값을 D로 지정하는 것이 인상깊어 남겨본다.
```
int score = 0;     // 점수를 저장하기 위한 변수 
char grade = 'D';  // 초기 값을 D로 지정해주므로써 else 구문 생략 가능 

System.out.print("점수를 입력하세요.> "); 
Scanner scanner = new Scanner(System.in);
score = scanner.nextInt(); // 화면을 통해 입력받은 숫자를 score에 저장

if(score >= 90) {          // score가 90점 보다 같거나 크면 A 학점
	grade = 'A';
} else if(score >= 80) {   // score가 80점 보다 같거나 크면 B 학점 
	grade = 'B';
} else if(score >= 70) {   // score가 70점 보다 같거나 크면 C 학점 
	grade = 'C';
} 
//else {             	   // 나머지는 D 학점 
//	grade = 'D';
//} 
System.out.println("당신의 학점은 " + grade + " 입니다.");
```

**중첩 if문 - if문 안의 if문**
- 들여쓰기에 관계 없이 else는 바로 직전에 if에 대응된다. 블럭을 사용해야하는 이유2.   
![중첩if문](중첩if문.png)

**switch 문**
- 처리해야 하는 경우의 수가 많을 때 유용한 조건문  
![switch문](switch문.png)
```
//switch문 예제

System.out.print("현재는 몇 월 인가요?> ");
Scanner scanner = new Scanner(System.in);
int month = scanner.nextInt();

switch(month) {
	case 3: case 4: case 5:
		System.out.println("현재 계절은 봄 입니다.");
		break;
	case 6: case 7: case 8:
		System.out.println("현재 계절은 여름 입니다.");
		break;
	case 9: case 10: case 11:
		System.out.println("현재 계절은 가을 입니다.");
		break;
	default:
		System.out.println("현재 계절은 겨울 입니다.");
```

**switch문의 제약조건**
- switch문의 조건식 결과는 정수 또는 문자열이어야 한다. (문자열은 1.7 버전부터 가능)
- case문의 값음 정수 상수(문자 포함, 변수X), 문자열만 가능하며, 중복되지 않아야 한다.  
![switch문제약조건](switch문제약조건.png)

**임의의 정수 만들기**
- Math.random() - 0.0과 1.0 사이의 임의의 double값을 반환
- 0.0 <= Math.random() < 1.0
	1. 각 변에 원하는 개별 값을 곱한다.
	2. 각 변을 int형으로 변환한다.
	3. 각 변에 1을 더한다.
```
1 <= (int)(Math.random() * 3) + 1 < 4 // 1 ~ 3 중 임의의 정수
-5 <= (int)(Math.random() * 11) - 5 < 6 // -5 ~ 5 중 임의의 정수 
```

**for문**
- 조건을 만족하는 동안 블럭{}을 반복 -> 반복 횟수를 알 때 적합
- '초기화 -> 조건식 -> 수행될 문장 -> 증감식 -> 조건식 -> ...' 순으로 진행  
![for문](for문.png)
```
// for문 예제
for (int i = 0; i < 3; i++) {
System.out.println("Hello.");
}

for (int i = 0, j = 0; i < 10; i++, j++) {  // 동시에 두 개 이상의 변수도 선언 가능
System.out.println(i * j);
}

int sum = 0;
for (int i = 0; i < 5; i++){
	sum += i; // sum = sum + i
	System.out.println("1부터 %2d 까지의 합: %2d%n", i, sum);
```
```
// for문 예제2 (변수의 범위가 인상깊어 남김)
class Ex_for {
	public static void main(String[] args){
		int i = 1;  // scope(범위) - 선언 위치부터 선언된 블럭 끝까지 유효(범위는 좁을 수록 좋다.)

		for( ; ; ){ //조건식을 생략하면, true로 간주되어 무한 반복문이 됨
			System.out.println("Hello");
		}
	}
}
```

**중첩 for문 예제**
```
// 구구단
for(int i = 2; i < 10; i++) {
	System.out.println(i + " 단.");
	for(int j = 1; j < 10; j++) {
		System.out.printf("%d * %d = %2d%n",i,j,i*j);
	}
	System.out.println(" ");
}
```
```
// '*' 별찍기(같은 숫자)
for(int i = 0; i < 5; i++) {           // 줄 수
	for(int j = 0; j < 10; j++) {  // 별 개수
		System.out.print("*");
	}
	System.out.println();          // 줄바꿈
}

// '*' 별찍기(계단식)
for(int i = 1; i <= 10; i++) {
	for(int j = 1; j <= i; j++) {  // i를 조건문에 넣어주므로써 i,j가 같이 늘어날 수 있게 함.
		System.out.print('*');
	}
	System.out.println();
}
```

**while문**
- 조건을 만족시키는 동안 블럭{}을 반복 -> 반복 횟수를 모를 때 적합
- while문과 for문은 서로 바꿔서 쓸 수 있다.(100%)  
![while문](while문.png)
```
import java.util.*;

public class Ex4_9_while {

	public static void main(String[] args) {

		int num = 0, sum = 0;
		
		System.out.print("숫자를 입력하세요.(예 : 12345)> ");
		Scanner scanner = new Scanner(System.in);
		num = scanner.nextInt();
		
		while(num > 0) {
			sum += (num % 10);
			System.out.printf("자리수 : %2d, 합계 : %3d, 현재 숫자 : %10d%n", num%10, sum, num);
			num = num / 10;
	
		}
	}
}
```

**do-while 문**
- 블럭{}을 최소한 한 번 이상 반복 -> 사용자 입력 받을 때 유용
```
do {
	// 조건식의 연산결과가 참일 때 수행될 문장들을 적는다.(처음 한 번은 무조건 실행)
} while(조건식); <- 끝에 ';'을 잊지 않도록 주의
```

**break 문**
- 자신이 포함된 **하나의 반복문**을 벗어난다.
```
int sum = 0;
int i = 0;

while(true) {  // while 문에서 조건은 생략 불가.( for( ; ; ) 형태로는 사용 가능.)
	if(sum > 100) {
		break; // sum이 100 보다 크면 '자신이 속한 하나의 반복문'을 벗어난다.
	}
	++i;
	sum += i;
}
System.out.println("i = " + i);
System.out.println("sum = " + sum);
```

**continue 문**
- 자신이 포함된 반복문의 끝으로 이동 -> 다음 반복으로 넘어감
- 전체 반복 중에서 특정 조건 시 반복을 건너뛸 때 유용  
![continue예제](continue예제.png)
```
for(int i = 0; i <= 10; i++){
	if(i % 3 == 0){
		continue;
	}
	System.out.println(i);
}
```

**이름 붙은 반복문**
- 반복문에 이름을 붙여서 하나 이상의 반복문을 벗어날 수 있다.
- 보통 break 문을 통해 한꺼번에 빠져나오고 싶을 때 사용하며,
- continue에도 사용할 수는 있지만 잘 쓰지 않는다.  
![이름붙은반복문예제](이름붙은반복문예제.png)

**조건문과 반복문, break, continue 통합 예제**
- 프로그램 전체적인 그림을 조건에 맞춰 먼저 구현하고 마지막에 주기능을 프로그래밍한 것이 인상 깊어 남긴다.
```
import java.util.*;

public class Ex4_14_menu {

	public static void main(String[] args) {

		int menu = 0, num = 0;
		Scanner scanner = new Scanner(System.in);

		outer: while (true) { // (무한)반복문 while에 outer라는 이름을 붙임
			System.out.println("(1) square");
			System.out.println("(2) square root");
			System.out.println("(3) log");
			System.out.print("원하는 메뉴(1~3)를 선택하세요.(종료:0)> ");

			String tmp = scanner.nextLine();
			menu = Integer.parseInt(tmp);

			if (menu == 0) { // 조건에 맞는 값인지 걸러주는 조건문
				System.out.println("프로그램을 종료합니다.");
				break;
			} else if (!(1 <= menu && menu <= 3)) {
				System.out.println("메뉴를 잘못 선택하셨습니다.(종료:0");
				continue;
			}

			for (;;) { // 입력한 조건에 따라 명령을 실행하는 (무한)반복문
				System.out.print("계산할 값을 입력하세요.(계산 종료:0, 전체 종료:99) > ");
				tmp = scanner.nextLine();
				num = Integer.parseInt(tmp);

				if (num == 0) { 
					break; // 계산 종료 for문을 벗어난다.(한껍데기만)
				} else if (num == 99) {
					System.out.println("프로그램을 종료합니다.");
					break outer; // outer로 지정한 반복문까지 벗어난다.
				}

				switch (menu) { // 명령 실행
				case 1:
					System.out.println("result : " + num + " square = " + num * num);
					break;
				case 2:
					System.out.println("result : " + num + " square root = " + Math.sqrt(num));
					break;
				case 3:
					System.out.println("result : " + num + " log = " + Math.log(num));
					break;
				}
			}
		}
	}
}
```


### **Ch5. 배열**

**배열이란?**
- 배열은 **같은 타입의 여러 변수**를 하나의 묶음으로 다루는 것

**배열의 선언**
- 배열을 다루기 위한 **참조변수**의 선언  
![배열의선언](배열의선언.png)  
※ '타입[] 변수이름;' 이 많이 쓰임. ('타입 변수이름[];' 의 경우 C style)  
```
타입[] 변수이름;           // 배열을 선언(배열을 다루기 위한 참조변수 선언)
변수이름 = new 타입[길이]; // 배열을 생성(실제 저장공간을 생성)

int[] score;               // int 타입의 배열을 다루기 위한 참조변수 score 선언
score = new int[5];        // int 타입의 값 5개를 저장할 수 있는 배열 생성
```

**배열의 인덱스**
- 배열의 인덱스(Index) : 각 요소에 자동으로 붙는 번호   
- "인덱스의 범위는 0부터 '배열길이-1' 까지"

**배열의 길이**
- 배열의 길이 : '배열이름.length'(int형 상수)  
- 배열은 한 번 생성하여 실행하는 동안 그 길이를 바꿀 수 없다.  
	- Why? : 배열은 메모리에 연속적으로 저장 -> 길이 변경 시 연속적 저장 불가할 수 있음.
	- 배열이 부족할 땐? : 새로운 배열을 만들어 기존 데이터를 복사한다.(다시 컴파일)
	- '배열이름.length' 사용 이유 : index 범위를 벗어나거나 틀리는 것을 방지하기 위해

**배열의 초기화** 
- 배열의 초기화란? : 배열의 각 요소에 처음으로 값을 저장하는 것
```
// OK
int[] score = new int[]{1,2,3,4,5,6};
int[] score = {1,2,3,4,5,6}; // 가장 간단하고 가장 많이 사용됨.
int[] score;
score = new int[]{1,2,3,4,5,6};

// Error
int[] score;
score = {1,2,3,4,5,6}
```

**배열의 출력**
```
// for문을 사용
for(int i = 0; i < arr.length; i++){
	System.out.println(arr[i]);
}

// Arrays.toString() 을 사용
System.out.println(Arrays.toString(arr)); // [arr[0], arr[1], arr[2], arr[3], arr[4]] 형태로 출력

// char[] 의 경우 예외를 용납함.
System.out.println(arrChar); // arrChar 가 char[] 인경우 문자열 형태로 출력됨.
-> 실제로 문자열은 문자(char)의 배열형태이다. 가장 마지막에는 \n이 들어감.
-> 문자열 data를 찾는 방식 : 문자열 가장 앞의 문자의 주소를 찾아가 \n이 있는 곳까지 읽음.
```

**배열의 활용 (예제)**
```
// max, min 값 찾기.
int[] arr = {99, 37, 77, 70, 12, 100, 50, 60};

int max = arr[0]; // max 초기화
int min = arr[0]; // min 초기화

for(int i = 0; i < arr.length; i++) {
	if(arr[i] > max) { 
		max = arr[i]; // 초기화된 값과 비교하여 더 크면 다시 저장
	} else if (arr[i] < min) {
		min = arr[i]; // 초기화된 값과 비교하여 더 작으면 다시 저장
	}
}
System.out.println("The max is " + max);
System.out.println("The min is " + min);
```
```
// 섞기 (Shuffle)
int[] arr = {0,1,2,3,4,5,6,7,8,9};
System.out.println(Arrays.toString(arr));

for(int i = 0; i < 100; i++) {
	int n = (int)(Math.random()*10);
				
	int tmp = arr[n]; // 두 값을 바꾸기 위해서는 빈 그릇이 필요하다.
	arr[n] = arr[0];
	arr[0] = tmp;
}
System.out.println(Arrays.toString(arr));
```
```
// lotto 번호 뽑기(shuffle 응용)
int[] lottoNum = new int[45]; // 공 45개를 위한 배열 선언
for(int i = 0; i < lottoNum.length; i++) { // 1~45번 공 넣기
	lottoNum[i] = i + 1;
}	
for(int j = 0; j < 6; j++) { // 인덱스 0~5 까지의 공을 random 공과 바꾼다.
	int n = (int)(Math.random()*45);
	
	int tmp = lottoNum[n];
	lottoNum[n] = lottoNum[j];
	lottoNum[j] = tmp;
}
System.out.print("This week's lotto numbers are ");
for(int k = 0; k < 6; k++) { // 바꾸어진 인덱스 0~5 까지의 공을 출력
	if(k == 5) {
		System.out.println(lottoNum[k]);
		break;
	}
	System.out.print(lottoNum[k] + ", ");
}
```

**String 배열의 선언과 생성**
- 여러개의 문자열을 저장할 수 있는 배열
- String 은 참조형 변수를 지정  
![자료형별기본값](자료형별기본값.png)  
- String[] name = new String[3];  
![String배열](String배열.png)  
![String배열2](String배열2.png)  

**String 클래스**
- String 클래스는 char[]와 메서드(기능)를 결합한 것
	- 문자열은 char 배열과 같은 의미
	- 'String클래스 = char[] + 메서드(기능)'
- String 클래스는 내용을 변경할 수 없다.(read only)
	- 동일한 변수명에 다시 저장하면 새로운 문자열을 만들어 참조
- String 클래스의 주요 메서드  
![String클래스주요메서드](String클래스주요메서드.png)  
```
String str = "ABCDE";

// 문자열 중 원하는 위치의 문자를 반환
char ch = str.charAt(2);
System.out.println(ch); // C index 2인 값을 뽑아냄

// 문자열 길이 반환
int leng = str.length();
System.out.println(leng); // 5 문자열의 길이

// 문자열 중 원하는 범위의 문자열을 반환
String str1 = str.substring(1,4);
String str2 = str.substring(1);
System.out.println(str1); // BCD index 1~3의 값을 반환(마지막 숫자의 index는 포함 안함)
System.out.println(str2); // BCDE index 1부터 끝까지 반환

// 문자열의 내용이 같은지 확인
boolean bool = str.equals("ABCDE");
System.out.println(bool); // true

// 문자열을 문자배열로 변환하여 반환
char[] charArr = str.toCharArray();
System.out.println(Arrays.toString(charArr)); // [A, B, C, D, E]
```

**2차원 배열(배열의 배열)**
- 테이블 형태의 데이터를 저장하기 위한 배열
- 2차원 배열의 인덱스  
![2차원배열인덱스](2차원배열인덱스.png)  
```
int[][] score = new int[4][3]; // 4행 3열의 2차원 배열 score을 생성
score[0][0] = 100;
System.out.println(score[0][0])
```

- 2차원 배열의 초기화
```
// 가능
int[][] arr = new int[][]{{1,2,3},{4,5,6}};
int[][] arr = {{1,2,3},{4,5,6}};

// 권장 방안
int[][] arr = {
		{100, 100, 100},
		{20, 20, 20},
		{30, 30, 30},
		{40, 40, 40}
	      };
```  
![2차원배열초기화](2차원배열초기화.png)  

- 2차원 배열 예제 : 2차원 배열은 2중 반복문과 함께 자주 사용
```
int[][] table = {
		{100,100,100},
		{20,20,20},
		{30,30,30},
		{40,40,40}
};

int sum = 0;
System.out.println(table.length);

// 2차원 배열의 경우 2중 반복문을 자주 사용한다.
for(int i = 0; i < table.length; i++) {
	for(int j = 0; j < table[i].length; j++) {
		System.out.println("score["+i+"]["+j+"]="+table[i][j]);
		sum += table[i][j];
	}
}
System.out.println("sum = " + sum);
```

**Arrays 클래스**
- 배열의 비교 : equals(), deepEquals()
	- equals() : 1차원 배열 비교 시 사용
	- deepEquals() : 다차원 배열 비교 시 사용
- 배열의 출력 : toString(), deepToString()
	- toString() : 1 차원 배열에만 사용 가능
	- deepToString() : 다차원 배열에 사용
```
// 배열의 출력
int[] arr = {0,1,2,3,4};
int[][] arr2D = {{11,12},{21,22}};

System.out.println(Arrays.toString(arr)); // [0, 1, 2, 3, 4] 1차원 배열에만 사용 가능
System.out.println(Arrays.deepToString(arr2D)); // [[11, 12], [21, 22]] 다차원 배열에 사용

// 배열의 비교
String[][] str2D =  new String[][]{{"aaa", "bbb"}, {"AAA", "BBB"}};
String[][] str2D2 = new String[][]{{"aaa", "bbb"}, {"AAA", "BBB"}};

System.out.println(Arrays.equals(str2D, str2D2)); // false
System.out.println(Arrays.deepEquals(str2D, str2D2)); // true
```

- 배열의 복사 : copyOf(), copyOfRange()
```
int[] arr1 = {0,1,2,3,4};
int[] arr2 = Arrays.copyOf(arr1,arr.length); // [0,1,2,3,4]
int[] arr3 = Arrays.copyOf(arr1, 3); // [0,1,2]
int[] arr4 = Arrays.copyOf(arr1, 7); // [0,1,2,3,4,0,0]
int[] arr5 = Arrays.copyOfRange(arr1, 2, 3); // [2]
int[] arr6 = Arrays.copyOfRange(arr1, 0, 7); // [0,1,2,3,4,0,0]
int[][] arrs = {arr1,arr2,arr3,arr4,arr5,arr6};

for(int i = 0; i < 6; i++) {
	System.out.println(Arrays.toString(arrs[i]));
}
```

- 배열의 정렬 : sort()
```
int[] arr = {3,2,0,4,1};
Arrays.sort(arr); // [0,1,2,3,4]
System.out.println(Arrays.toString(arr));
```

### **Ch6. 객체지향 프로그래밍1**

**객체지향 언어**
- `80년대 초 소프트웨어의 위기 : 빠른 변화를 쫓아가지 못함
- 그 해결책으로 객체지향 언어를 도입(절차적 -> 객체지향)
- 코드의 재사용성을 높이고 유지보수를 용이하게 함, 중복된 코드 제거
- 객체지향 언어 = 프로그래밍 언어 + 객체지향개념(규칙)
- 객체지향언어(OOP: Object Oriented Programming)의 4대 핵심 개념
	1. 캡슐화
	2. 상속
	3. 추상화
	4. ★다형성★

**클래스와 객체**
- 클래스의 정의 : 클래스란 객체를 정의해 놓은 것
- 클래스의 용도 : 클래스는 객체를 생성하는데 사용
- 객체의 정의 : 실제로 존재하는 것. 사물 또는 개념
- 객체의 용도 : 객체가 가지고 있는 기능과 속성에 따라 다름  
![클래스와객체](클래스와객체.png)

**객체의 구성요소 - 속성과 기능**
- 객체지향의 개념은 실제세계(HW)를 가상세계(SW)에 넣는 것
- 객체 = 속성(변수) + 기능(메서드)
![객체속성과기능](객체속성과기능.png)

**객체와 인스턴스**
- 객체 : 모든 인스턴스를 대표하는 일반적 용어
- 인스턴스 : 특정 클래스로부터 생성된 객체(예: Tv 인스턴스)  
![객체와인스턴스](객체와인스턴스.png)  
![인스턴스화](인스턴스화.png)

**클래스와 객체 Q&A**
Q. 클래스가 필요한 이유 - A. 객체를 생성하기 위해  
Q. 객체가 필요한 이유 - A. 사용하기 위해서  
Q. 객체를 사용한다는 것은? - A. 객체가 가진 속성과 기능을 사용하는 것  

**하나의 소스파일에 여러 클래스 작성** 
- 불가능하지 않으나, 가능하면 하나의 소스파일에는 하나의 클래스만 작성하는 것이 바람직
![클래스올바른작성예](클래스올바른작성예.png)  
![클래스잘못된작성예](클래스잘못된작성예.png)  

**객체의 생성과 사용**
- 클래스를 작성하고, 객체의 생성 후,사용
- 클래스명 변수명; -> 클래스의 객체를 참조하기 위한 참조변수를 선언
- 변수명 = new 클래스명(); -> 클래스의 객체를 생성 후, 객체의 주소를 참조변수에 저장
- 하나의 인스턴스를 여러 개의 참조변수가 가리키는 경우는 가능
- 여러 인스턴스를 하나의 참조변수가 가리키는 경우는 불가능
```
// 1. 클래스 작성

class Tv {
	String color;  // 변수(색깔)
	boolean power; // 변수(전원상태)
	int channel;   // 변수(채널)

	void power() {power = !power;}  // 메서드(전원)
	void channerlUp() {channer++;}  // 메서드(채널+)
	void channelDown() {channel--;} // 메서드(채널-)
}

// 2. 객체의 생성
Tv t;                   // 'Tv클래스 타입'의 참조변수 t를 선언
t = new Tv();           // Tv인스턴스를 생성한 후, 생성된 Tv인스턴스의 주소를 t에 저장

// 3. 객체의 사용
t.channel = 7;          // Tv인스턴스의 멤버변수 Channel의 값을 7로 한다.
t.channelDown();        // Tv인스턴스의 메서드 ChannelDown()을 호출한다.
System.out.println("현재 채널은 " + t.channel + "입니다.");
```

**객체 배열**
- 객체 배열 == 참조변수의  배열
- 참조변수의 배열만 생성하고 객체를 생성하지 않는 경우가 많다. 주의할 것.
```
Tv[] tvArr = new Tv[3]; // 길이가 3인 Tv 타입의 참조변수 배열 생성

// 객체를 생성해서 배열의 각 요소에 저장★★
tvArr[0] = new Tv();
tvArr[1] = new Tv();
tvArr[2] = new Tv();
```

**클래스의 정의**
- 클래스의 3가지 정의(기능)
	1. 설계도
	2. 서로 관련된 데이터와 함수의 결합 
	3. 사용자가 직접 정의한 타입

- 클래스 == 데이터 + 함수  
![데이터저장개념의발전과정](데이터저장개념의발전과정.png)  
> 변수 : 하나의 데이터를 저장할 수 있는 공간
> 배열 : 같은 종류의 여러 데이터를 하나로 저장할 수 있는 공간
> 구조체 : 서로 관련된 여러 데이터(종류 관계X)를 하나로 저장할 수 있는 공간
> 클래스 : 데이터와 함수의 결합(구조체 + 함수)

- 사용자 정의 타입(User-defined type)
	- 프로그래머가 직접 새로운 타입을 정의할 수 있음
	- 서로 관련된 값을 묶어서 하나의 타입으로 정의
![클래스사용자정의타입](클래스사용자정의타입.png)

**선언위치에 따른 변수의 종류**
- 클래스 영역 
	- 클래스 변수(CV:class variable) : 아무때나 사용 가능. 객체 생성 필요 없음
	- 인스턴스 변수(IV:instance variable) : 인스턴스와 함께 생성, 소멸. 객체 생성 필요
- 클래스 영역 이외의 영역(메서드 생성자, 초기화 블럭 내부)
	- 지역 변수(LV:local variable) : 변수 선언문 수행 시 생성, 종료 시 소멸 
![선언위치에따른변수종류](선언위치에따른변수종류.png)

**클래스 변수와 인스턴스 변수**
- 클래스 변수
	- 공통 속성을 표현할 때 사용, 변수 정의 시 앞에 'static'을 붙임
	- 모든 인스턴스가 하나의 저장공간을 공유
- 인스턴스 변수
	- 개별 속성을 표현할 때 사용
![클래스변수와인스턴스변수](클래스변수와인스턴스변수.png)

**메서드(Method)**
- 특정 작업을 수행하는 일련의 문장들을 묶어놓은 것
- 함수와 기능적으로 유사(거의 같음)하다. 
	- 메서드 : 클래스 안에 있어야함, 함수 : 클래스에 독립적
- 값을 입력 받아서 처리하고, 결과를 반환(출력)
- 메서드는 선언부와 구현부로 이루어짐  
	- 선언부 : 반환타입, 메서드이름, 입력 변수
	- 구현부 : 메서드 호출 시 수행될 코드
![메서드](메서드.png)  
- 메서드의 장점
	- 코드의 중복을 줄일 수 있다.
	- 코드의 관리가 쉽다.
	- 코드를 재사용할 수 있다.
	- 코드가 간결하여 이해하기 쉬워진다.
- 메서드 작성 시 참고사항
	- 메서드는 클래스 영역에만 정의 가능
	- 반복적으로 수행되는 여러 문장을 메서드로 작성
	- 하나의 메서드는 한 가지 기능만 수행하도록 작성
	- 반환값은 0~1개(여러개의 출력값은 배열 혹은 객체 이용)
	- 반환값이 없는 경우 반환 타입에 'void'라고 입력

**메서드 호출, 반환**
- 메서드이름(); -> 입력값이 없는 경우
- 메서드이름(값1, 값2, ...); -> 입력값이 있는 경우
```
print99danAll(); // void print99danAll()을 호출
int result = add(3, 5); // int add(int x, int y)를 호출하고, 결과(반환값)를 result에 저장
```
- return 문
	- 실행 중인 메서드를 종료하고 **메서드를 호출한 곳**으로 되돌아 감
	- 반환 타입이 **void 인 경우** 생략 가능
	- 조건문과 사용하는 경우 조건식이 참일 때(반환 가능할 때)만 실행됨
	- 반환값은 지정된 메서드 반환 타입과 타입이 일치해야 함(혹은 자동형변환 가능)

**호출 스택(Call Stack)**
- 스택(Stack) : 밑이 막힌 상자. 위에 차곡차곡 쌓인다.
- 메서드가 호출되면 수행에 필요한 만큼의 메모리를 스택에 할당받는다.
- 메서드가 수행을 마치고나면 사용했던 메모리를 반환하고 스택에서 제거된다.
- 호출스택의 제일 위에 있는 메서드가 현재 실행 중인 메서드이다.
- 아래에 있는 메서드가 바로 위의 메서드를 호출한 메서드이다.
![호출스택](호출스택.png)
 

**기본형, 참조형 매개변수**
- 기본형 매개변수 : 변수의 값을 읽기만 할 수 있음(read only)
- 참조형 매개변수 : 변수의 값을 읽고 변경할 수 있음(read & write)
```
// 기본형 매개변수 예제

class Data{ int x; }

public class Ex6_6{

	public static void main(String[] args) {
		Data d = new Data();
		d.x = 10;
		System.out.println("main() : x = " + d.x);
		
		change(d.x);

		System.out.println("After change(d.x)");
		System.out.println("main() : x = " + d.x);
	}
	
	static void change(int x) { // 기본형 매개변수
		x = 1000;
		System.out.println("chang() : x = " + x);
	}
}
```
```
// 참조형 매개변수 예제

class Data2 { int x;}

public class Ex6_7 {
	public static void main(String[] args) {
		Data2 d = new Data2();
		d.x = 10;
		System.out.println("main() : x = " + d.x);
		
		change(d);

		System.out.println("after change(d)");
		System.out.println("main() : x = " + d.x);
		
	}

	static void change(Data2 a) { //참조형 매개변수(객체의 리모컨(객체 참조 주소)을 한꺼번에 넘겨 받음)
		a.x = 1000;
		System.out.println("change() : x = " + a.x);
	}
	
}
```
```
// 참조형 반환타입 예제
class Data3 {int x;}

public class Ex6_8 {
	
	public static void main(String[] args) {
		
		Data3 d = new Data3();
		d.x = 10;
		d.y = 100;
		
		Data3 d2 = copy(d); // copy(d)에서 반환된 객체를 d2에 저장
		
		System.out.println("d.x = " + d.x);
		System.out.println("d.y = " + d.y);
		System.out.println("d2.x = " + d2.x);
		System.out.println("d2.y = " + d2.y);
		
	}

	static Data3 copy(Data3 a) { // 참조형 반환타입 'Data3'
		
		Data3 tmp = new Data3(); // 새로운 객체 생성(매개형태)
		
		tmp = a; // 새로운 객체에 입력된 객체를 복사한다.
		
		return tmp; // 객체의 주소를 반환
	}
}
```

**static 메서드와 인스턴스 메서드**
- 인스턴스 메서드
	- 인스턴스 생성 후, '참조변수.메서드이름()'으로 호출
	- 인스턴스 멤버(IV(instance variable), IM(instance method))와 관련된 작업을 하는 메서드
	- 메서드 내에서 인스턴스 변수 사용 가능
- static 메서드(클래스 메서드)
	- 객체 생성 없이 '클래스이름.메서드이름()'으로 호출
	- 인스턴스 멤버(IV, IM)와 관련없는 작업을 하는 메서드
	- 메서드 내에서 인스턴스 변수 사용 불가 
```
class MyMath2 {
	long a, b;
	
	// 인스턴스 변수 a, b만을 이용해서 작업하므로 매개변수가 필요 없음(매개변수를 활용할 수도 있음)
	long add() {return a + b;} // a, b는 인스턴스 변수
	long diff() {return a - b;}
	long mult() { return a * b;}
	double div() {return a / b;}
	
	// 인스턴스 변수와 관계없이 매개변수만으로 작업이 가능
	static long add(long c, long d) {return c + d;} // a, b는 지역변수 
	static long diff(long c, long d) {return c - d;}
	static long mult(long c, long d) {return c * d;}
	static double div(long c, long d) {return c / d;}
	
}

public class Ex6_9 {
	public static void main(String[] args) {
		// 클래스 메서드 호출. 인스턴스 생성없이 호출 가능
		System.out.println(MyMath2.add(200L,100L));
		System.out.println(MyMath2.diff(200l, 100l));
		System.out.println(MyMath2.mult(200l, 100l));
		System.out.println(MyMath2.div(200L, 100L));
		
		MyMath2 mm = new MyMath2(); // 인스턴스를 생성
		mm.a = 100L;
		mm.b = 200L;
		// 인스턴스 메서드는 객체생성 후에만 호출이 가능
		System.out.println(mm.add());
		System.out.println(mm.diff());
		System.out.println(mm.mult());
		System.out.println(mm.div());
	}
}
```

**static을 언제 붙여야 할까?**
- 속성(멤버 변수) 중에서 **공통 속성**에 static을 붙인다.
- 클래스 변수(static 변수)는 인스턴스를 생성하지 않아도 사용할 수 있다.
- 클래스 메서드(static 메서드)는 인스턴스 변수를 사용할 수 없다.
- 메서드 내에서 인스턴스 변수를 사용하지 않는다면, static을 붙이는 것을 고려한다.

**메서드 간의 호출과 참조**
- 같은 클래스에 속한 멤버들 간에는 별도의 인스턴스를 생성하지 않고도 서로 참조 또는 호출 가능
- 단, 클래스 멤버가 인스턴스 멤버를 참조 또는 호출하고자 하는 경우 인스턴스 생성해야 함
- 인스턴스 멤버가 존재하는 시점에 클래스 멤버는 항상 존재하지만, 반대의 경우는 그렇지 않기 때문  
```
class TestClass {
	void instanceMethod() {} // 인스턴스 메서드
	static void staticMathod() {} // static 메서드

	void instanceMethod2() { // 인스턴스 메서드 
		instanceMethod(); // 다른 인스턴스 메서드를 호출한다.
		staticMethod(); // static 메서드를 호출한다.
	}

	static void staticMethod2() { // static 메서드
		instanceMethod(); // ★에러!!★ 인스턴스 메서드 호출 불가
		staticMethod(); // static 메서드는 호출 가능
	}
}
```   
```
class TestClass2 {
	int iv; // 인스턴스 변수
	static int cv; // 클래스 변수

	void instanceMethod() { // 인스턴스 메서드
		System.out.println(iv); // 인스턴스 변수 사용 가능
		System.out.println(cv); // 클래스 변수 사용 가능
	}

	static void staticMethod() { // 클래스 메서드
		System.out.println(iv); // ★에러!!★ 인스턴스 변수 사용 불가
		System.out.println(cv); // 클래서 변수는 사용 가능
	}
}
```

**오버로딩(overloading)**
- 한 클래스 안에 같은 이름의 메서드 여러 개를 정의하는 것
- 자료형에 따라 발생하는 에러를 방지하기 위해 동일 명령을 입력값의 자료형을 다양하게 하여 여러개 생성
- 오버로딩이 성립하기 위한 조건(모두 만족해야 함)
	- 메서드 이름이 같아야 한다.
	- 매개변수의 개수 또는 타입이 달라야 한다.
	- 반환 타입은 영향없다.
```
public class Ex6_10 {
	public static void main(String[] args) {
		
		MyMath3 mm = new MyMath3();
		
		System.out.println("mm.add(3,3)의 결과 : " + mm.add(3, 3));
		System.out.println("mm.add(3,3L)의 결과 : " + mm.add(3, 3L));
		System.out.println("mm.add(3L,3)의 결과 : " + mm.add(3L, 3));
		System.out.println("mm.add(3L,3L)의 결과 : " + mm.add(3L, 3L));
		
		int[] a = {100, 200, 300};
		
		System.out.println("mm.add(int[] a)의 결과 : " + mm.add(a));
		
	}
}

// 오버로딩의 올바른 예 - 매개변수는 다르지만 같은 의미의 기능 수행
class MyMath3 {
	int add(int a, int b) {
		System.out.print("int add(int a, int b) - ");
		return a + b;
	}

	long add(int a, long b) {
		System.out.print("int add(int a, long b) - ");
		return a + b;
	}
	
	long add(long a, int b) {
		System.out.print("int add(long a, int b) - ");
		return a + b;
	}
	
	long add(long a, long b) {
		System.out.print("long add(long a, long b) - ");
		return a + b;
	}

	int add(int[] a) {
		System.out.print("int add(int[] a) - ");
		int result = 0;
		for(int i = 0; i < a.length; i++) {
			result += a[i];
		}
		return result;
	}
}
```

**생성자(Constructor)**
- 인스턴스가 생성될 때마다 호출되는 **인스턴스 초기화 메서드**
- 인스턴스 생성 시 수행할 작업(IV 초기화)에 사용
- 이름이 클래스 이름과 같아야 한다.
- 리턴값이 없다.(항상 반환값이 없으므로 void 도 안붙임)
- 모든 클래스는 반드시 생성자를 가져야 한다.
```
class Point {
	Point(){ // 매개변수가 없는 생성자
		...
	}

	Point(int x, int y){ // 매개변수가 있는 생성자
		...
	}
}
```

**기본 생성자(default constructor)**
- 매개변수가 없는 생성자
- 생성자가 하나도 없을 때만, 컴파일러가 자동 추가
- 기본 생성자가 컴파일러에 의해서 추가되는 경우는 클래스에 정의된 생서자가 하나도 없을 때 뿐이다.
- class 생성 시 **기본 생성자** 만들어주는 습관 가질 것
```
클래스이름(){} // 기본 생성자
Point(){} // Point 클래스의 기본 생성자
```
```
// 생성자 에러 예제
public class Ex6_11 {
	public static void main(String[] args) {
		Data_1 d1 = new Data_1();
		Data_2 d2 = new Data_2(); // Data_2()가 정의되지 않았다는 에러 발생
		// The constructor Data_2() is undefined 
	}
}

class Data_1 { // 생성자 없으므로 기본 생성자 자동 생성
	int value;
}

class Data_2 {
	int value;
	Data_2(int x) { // 생성자 있음에 따라 기본 생성자 자동 생성 안됨
		value = x;
	}
}
```

**매개변수가 있는 생성자**
```
class Car {
	String color;
	String gearType;
	int door;
	
	Car(){} // 기본 생성자
	
	Car(String c, String g, int d){ // 매개변수가 있는 생성자
		color = c;
		gearType = g;
		door = d;
	}
}

public class Ex6_12 {
	public static void main(String[] args) {	
		// 인스턴스 생성법 1 (기본 생성자를 이용한 생성)
		Car car1 = new Car();
		car1.color = "blue";
		car1.gearType = "auto";
		car1.door = 4;
		
		// 인스턴스 생성법 2 ( 매개변수 생성자를 이용한 생성)
		Car car2 = new Car("white", "auto", 2);
		
		// 출력
		System.out.println("car1의 color : "+car1.color+", gear type : "+car1.gearType
							+ ", door : "+car1.door);
		System.out.println("car2의 color : "+car2.color+", gear type : "+car2.gearType
							+ ", door : "+car2.door);
	}
}
```

**생성자 this()**
- 생성자에서 클래스 내 다른 생성자 호출할 때 사용
- 다른 생성자 호출 시 첫 줄에서만 사용 가능
```
class Car2 {
	String color;
	String gearType;
	int door;
	
	Car2() {
		this("white", "auto", 4); // 아래 모두 지정된 생성자를 불러옴
	}
	
	Car2(String color) {
		this(color, "auto", 4); // 일부만 불러오는 것도 가능
	}
	
	Car2(String c, String g, int d ){
		this.color = c;
		this.gearType = g;
		this.door = d;
	}
}

public class Ex6_13_this {
	public static void main(String[] args) {
		Car2 c1 = new Car2();
		Car2 c2 = new Car2("blue");
		Car2 c3 = new Car2("green", "auto", 2);
		
		System.out.println(c1.color +" "+ c1.gearType +" "+ c1.door);
		System.out.println(c2.color +" "+ c2.gearType +" "+ c2.door);
		System.out.println(c3.color +" "+ c3.gearType +" "+ c3.door);
	}
}
```

**참조변수 this - 생성자 this()와 별개로 생각하자**
- 인스턴스 자신을 가리키는 참조 변수, 인스턴스의 주소가 저장되어 있음
- 인스턴스 메서드(생성자 포함)에서 사용 가능(static 메서드에서는 사용 불가)
- 지역변수(LV)와 인스턴스 변수(IV)를 구별할 때 사용  
![참조변수this](참조변수this.png)

**변수의 초기화**
- 지역변수(local variable)는 수동 초기화 해야함(사용 전 꼭!!)
- 멤버변수(클래스 변수와 인스턴스 변수)와 배열의 초기화는 선택이지만,  지역변수의 초기화는 필수이다.
```
class InitTest {
	int x;     // 인스턴스 변수
	int y = x; // 인스턴스 변수 

	void method1() {
		int i;
		int j = i; // 에러. 지역변수를 초기화하지 않고 사용
```
![자료형기본값](자료형기본값.png)

**멤버변수(클래스 변수와 인스턴스 변수)의 초기화**
- 클래스 변수 초기화 시점 : 클래스가 처음 로딩될 때 한 번
- 인스턴스 변수 초기화 시점 : 인스턴스가 생성될 때 마다
- 초기화 순서
	- 클래스 변수(cv) 초기화 -> 인스턴스 변수(iv) 초기화
	- 자동 초기화 -> 명시적 초기화(간단) -> 초기화 블럭, 생성자(복잡)
```
class InitTest {
	static int cv = 1; // 명시적 초기화
	int iv = 1; // 명시적 초기화

	static { cv = 2; } // 클래스 초기화 블럭
	{ in = 2; } // 인스턴스 초기화 블럭

	InitTest() { // 생성자
		iv = 3;
	}
}
```
![초기화순서](초기화순서.png)  
- 명시적 초기화(explicit initialization)
	- 변수를 선언과 동시에 초기화 하는 것
```
class Car {
	int door = 4; // 기본형(primitive type) 변수의 초기화
	Engine e = new Engine(); // 참조형(reference type) 변수의 초기화
	...
}
- 초기화 블럭(initialization block)
	- 인스턴스 초기화 블럭 '{}' : 인스턴스 변수의 복잡한 초기화에 사용
	- 클랙스 초기화 블럭 'static {}' : 클래스 변수의 복잡한 초기화에 사용
- 생성자(constructor)
	- 인스턴스 변수(iv) 초기화. 복잡한 초기화

```
```
public class Ex6_14 {
	
	static int[] arr = new int[10]; // 명시적 초기화
	
	static { // 클래스 초기화 블럭 - 배열 arr을 난수로 채운다.
		for(int i = 0; i < arr.length; i++) {
			arr[i] = (int)(Math.random()*10 + 1);
		}
	}

	public static void main(String[] args) {
		for(int i = 0; i < arr.length; i++) {
			System.out.println("arr["+i+"] = "+arr[i]);
		}
	}
}
```

### **Ch7. 객체지향 프로그래밍2**
**상속 (Inheritance)**
- 기존의 클래스로 새로운 클래스를 작성하는 것.(코드의 재사용)
- 두 클래스를 부모와 자식으로 관계를 맺어주는 것.
- 자손은 조상의 모든 멤버를 상속 받는다.(생성자, 초기화블럭 제외)
- 자손의 멤버 개수는 조상보다 적을 수 없다.(같거나 많다.)
- 자손의 변경은 조상에 영향을 미치지 않는다.
```
// 예제 7_1
class Tv{
	boolean power;
	int channel;
	
	void power() {power = !power;}
	void channelUp() {++channel;}
	void channelDown() {--channel;}
}

class SmartTv extends Tv{
	boolean caption;
	
	void displayCaption(String text) {
		if(caption) {
			System.out.println(text);
		}
	}
}

public class Ex7_1_Inheritance {
	public static void main(String[] args) {
		SmartTv stv = new SmartTv();
		stv.channel = 10; // 조상 클래스로부터 상속받은 멤버
		stv.channelUp(); // 조상 클래스로부터 상속받은 멤버
		System.out.println(stv.channel);
		stv.displayCaption("Hello, World");
		stv.caption = true; // 캡션(자막) 기능을 켠다.
		stv.displayCaption("Hello, World"); // caption 이 'true'일 때만 출력
	}
}
```

**포함 관계**
- 포함(composite)이란? : 클래스의 멤버로 참조변수를 선언하는 것
- 작은 단위의 클래스를 만들고, 이들을 조합해서 클래스를 만든다.
```
class Car {
	Engine e = new Engine(); // 엔진 객체 생성 후 포함
	Door[] d = new Door[4](); // 문(4개) 생성하여 배열처리
...
```

**클래스 간의 관계 결정**
- 대부분 포함으로 진행한다.
- 상속관계 : '~은 ~이다.(is-a)'
- 포함관계 : '~은 ~을 가지고 있다.(has-a)'
- 예시)
	- 원(Circle)은 점(Point)이다. 
	- 원(Circle)은 점(Point)을 가지고 있다. -> 더 자연스러움(포함관계)

```
class Point{
	int x;
	int y;
}

class Circle1 extends Point { // 상속
	int r;
}

class Circle2 { // 포함
	Point p = new Point();
	int r;
}
public class Ex7_2_Relationship {
	public static void main(String[] args) {
		Circle1 c1 = new Circle1();
		c1.x = 1;
		c1.y = 2;
		c1.r = 3;
		System.out.println("c1.x = "+c1.x);
		System.out.println("c1.y = "+c1.y);
		System.out.println("c1.r = "+c1.r);
		
		Circle2 c2 = new Circle2();
		c2.p.x = 4; // 포함은 인스턴스를 두 번 참조 해줘야 한다.
		c2.p.y = 5;
		c2.r = 6;
		System.out.println("c2.p.x = "+c2.p.x);
		System.out.println("c2.p.y = "+c2.p.y);
		System.out.println("c2.r = "+c2.r);
	}
}
```

**단일 상속(Single Inheritance)**
- Java는 단일상속만을 허용한다.(C++은 다중상속 허용)
- 비중이 높은 클래스 하나만 상속관계로, 나머지는 포함관계로 한다.

**Object 클래스 - 모든 클래스의 조상**
- 부모가 없는 클래스는 자동적으로 Object 클래스를 상속 받게 된다.
- 모든 클래스는 Object클래스에 정의된 11개의 메서드를 상속 받는다.
	- toString(), equals(Object obj), hashCode(), ...
- 컴파일러가 아래와 같이 자동 추가  
![Object클래스](Object클래스.png)  

**오버라이딩(Overriding)**
- 상속 받은 조상의 메서드를 자신에 맞게 변경하는 것
```
class Point{
	int x;
	int y;
	
	String getLocation() {
		return "x = "+x+", y = "+y;
	}
}

class Circle1 extends Point {
	int r;
	
	String getLocation() { // 메서드를 오버라이딩(덮어쓰기) 해준다.
		return "x ="+x+", y = "+y+", r = "+r;
	}
}

public class Ex7_2_Relationship {
	public static void main(String[] args) {
		Point p = new Point();
		Circle1 c3 = new Circle1();
		p.x = 1;
		p.y = 2;
		c3.x = 4;
		c3.y = 5;
		c3.r = 6;
		System.out.println(p.getLocation()); // x = 1, y = 2
		System.out.println(c3.getLocation()); // x = 4, y = 5, r = 6
	}
}
```

**오버라이딩의 조건**
- 선언부가 조상 클래스의 메서드와 일치해야 한다.(반환타입, 메서드 이름, 매개변수 목록)
- 접근 제어자를 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없다.
- 예외는 조상 클래스의 메서드보다 많이 선언할 수 없다.

**오버로딩과 오버라이딩**
- 큰 상관 없으나 헷갈리는 경우가 많다.
- 오버로딩(overloading) : 기존에 없는 새로운 메서드를 정의하는 것(new)
- 오버라이딩(overriding) : 상속 받은 메서드의 내용을 변경하는 것(change, modify)
```
class Parent{
	void parentMethod() {}
}

class Child{
	void parentMethod(){} // 오버라이딩
	void parentMethod(int i){} // 오버로딩

	void childMethod(){}
	void childMethod(int i){} // 오버로딩
	void childMethod(){} // 에러. 중복정의(already defined in Child)
}
```

**참조변수 super**
- 객체 자신을 가리키는 참조변수(this와 유사함)
- 인스턴스 메서드(생성자) 내에만 존재(static 메서드 내에 사용 불가)
- 조상의 멤버를 자신의 멤버와 구별할 때 사용
```
public class Ex7_3_super {
	public static void main(String[] args) {
		Child c = new Child();
		c.method();
		System.out.println("c.x = "+c.x); // c.x = 20
	}
}

class Parent {int x = 10;}

class Child extends Parent {
	int x = 20;
	
	void method() {
		System.out.println("x = "+x); // x = 20
		System.out.println("this.x = "+this.x); // this.x = 20
		System.out.println("super.x = "+super.x); // super.x = 10
	}
} 
```

**super() - 조상의 '생성자'**
- 조상의 생성자를 호출할 때 사용
- 조상의 멤버는 조상의 생성자를 호출해서 초기화(조상 멤버는 super()로 초기화 하는 것이 좋다.)
- 생성자의 첫 줄에는 반드시 생성자를 호출해야 한다.
- 그렇지 않으면, 컴파일러가 생성자의 첫 줄에 super();를 삽입
```
public class Ex7_4_super {
	public static void main(String[] args) {
		Point3D p3 = new Point3D(4,5,3);
		System.out.println("x = "+p3.x+", y = "+p3.y+", z = "+p3.z);
	}
}

class Point1 {
	int x, y;
	
	Point1(int x, int y){
		this.x = x;
		this.y = y;
	}
}

class Point3D extends Point1{
	int z;
	
	Point3D(int x, int y, int z){
		super(x, y); // Point(int x, int y)를 호출
		this.z = z;
	}
}
```

**패키지(package)**
- 서로 관련된 클래스의 묶음
- 클래스는 클래스 파일'*.class', 패키지는 폴더. 하위 패키지는 하위 폴더
- 클래스의 실제 이름(full name)은 패키지를 포함. 'java.lang.String'
- 'rt.jar'는 클래스들을 압축한 파일(java9 부터 모듈개념 생기면서 없어짐)

**패키지의 선언**
- 패키지는 소스파일의 첫번째 문장으로 단 한 번 선언
- 같은 소스 파일의 클래스들은 모두 같은 패키지에 속하게 된다.
- 패키지 선언이 없으면 이름 없는(unnamed) 패키지에 속하게 된다.

**클래스 패스(classpath)**
- 클래스 파일'*.class'의 위치를 알려주는 경로(path)
- 환경변수 classpath로 관리하며, 경로 간의 구분자는 ';'를 사용
- classpath(환경변수)에 패키지의 루트를 등록해줘야 함

**import 문**
- 클래스를 사용할 때 패키지 이름을 생략할 수 있다.  
![import문](import문.png)  
- java.lang 패키지의 클래스는 import하지 않고도 사용할 수 있다.
	- String, Object, System, Thread, ...
	- 원래 패키지 'java.lang.*';
- import 문 선언 방법
	- import 패키지명.클래스명;
	- import 패키지명.*; <- '*'은 패키지 내 모든 클래스를 의미(패키지 포함 X)
	- import 문은 패키지문과 클래스 선언 사이에 선언한다.
	- import 문은 컴파일 시에 처리되므로 프로그램 성능에 영향 없음
	- 이름이 같은 클래스가 속한 두 패키지를 import 할 때는 클래스 앞에 패키지명 붙여줘야 한다.

**static import 문**
- static 멤버를 사용할 때 클래스 이름을 생략할 수 있다.
```
import static java.lang.System.out;
import static java.lang.Math._*_;

public class Ex7_6_staticImport {
	public static void main(String[] args) {
		// System.out.println(Math.random());
		out.println(random());
		
		//System.out.println("Math.PI : " + Math.PI);
		out.println("Math.PI : " + PI);
	}
}
```

**제어자(modifier)**
- 클래스와 클래스의 멤버(멤버 변수, 메서드)에 부가적인 의미 부여
	- **접근 제어자** : public, protected, (default), private
	- **그 외** : static, final, abstract, native, transient, synchronized, volatile, strictfp  
- 하나의 대상에 여러 제어자를 같이 사용가능(접근 제어자는 하나만)

- static : 클래스의, 공통적인
![static제어자](static제어자.png)  
```
class StaticTest {
	static int width = 200; // 클래스 변수(static 변수)
	static int height = 100; // 클래스 변수(static 변수)

	static { // 클래스 초기화 블럭
		// static 변수의 복잡한 초기화 수행
	}

	static int max(int a, int b) { // 클래스 메서드(static 메서드)
		return a > b ? a : b;
	}
}
```
- final : 마지막의, 변경될 수 없는
![final제어자](final제어자.png)  
```
final class FinalTest { // 조상이 될 수 없는 클래스
	final int MAX_SIZE = 10; // 값을 변경할 수 없는 멤버변수(상수)

	final void getMaxSize() { // 오버라이딩할 수 없는 메서드(변경불가)
		final int LV = MAX_SIZE; // 값을 변경할 수 없는 지역변수(상수)
		return MAX_SIZE;
	}
}
```
- abstract : 추상의, 미완성의
![abstract제어자](abstract제어자.png)  
```
abstract class AbstractTest { // 추상 클래스(추상 메서드를 포함한 클래스)
	abstract void move(); // 추상 메서드(구현부가 없는 메서드)
}

AbstractTest a = new AbstractTest(); // 에러. 추상 클래스의 인스턴스는 생성 불가
```
- 접근 제어자(access modifier)
	- private : 같은 클래스 내에서만 접근이 가능하다.
	- (default) : 같은 패키지 내에서만 접근이 가능하다.
	- protected : 같은 패키지 내에서, 그리고 다른 패키지의 자손클래스에서 접근이 가능하다.
	- public : 접근 제한이 전혀 없다.  
![접근제어자1](접근제어자1.png)  
![접근제어자2](접근제어자2.png)  
![접근제어자3](접근제어자3.png)  

**캡슐화와 접근 제어자**
- 접근 제어자 사용 이유
	- 외부로부터 데이터를 보호하기 위해
	- 외부에는 불필요한(내부적으로만 사용되는) 부분을 감추기 위해
```
// 캡슐화 예제
class Time {
	private int hour; // 0~23 사이 값을 가져야 함
	private int minute; // 0~59 사이 값을 가져야 함
	private int second; // 0~59 사이 값을 가져야 함
	
	public void setHour(int hour) { // 메서드를 통해 인스턴스 변수에 접근. 유효성 검사
		if(hour < 0 || hour > 23) { return;}
		this.hour = hour;
	}
	public int getHour() { return hour;	}
	
	public void setMinute(int minute) {
		if(minute < 0 || minute > 59) { return; }
		this.minute = minute;
	}
	public int getMinute(){ return minute; }
	
	public void setSecond(int second) {
		if(second < 0 || second > 59) { return; }
		this.second = second;
	}
	public int getSecond() { return second; }
}

public class Ex7_7_timeTest {
	public static void main(String[] args) {
		Time t = new Time();
		//t.hour = 100;  private 타입으로 접근 불가
		t.setHour(11); // 메서드를 통해 속성(변수)에 접근
		t.setMinute(40);
		t.setSecond(15);
		System.out.println(t.getHour()+"시 "+t.getMinute()+"분 "+t.getSecond()+"초");
	}
}

```

**다형성(polymorphism)**
- 여러가지 형태를 가질 수 있는 능력
- 조상 타입 참조 변수로 자손 타입 객체를 다루는 것
- 자손 타입의 참조변수로 조상 타입의 객체를 가리킬 수는 없다.
![다형성](다형성.png)  

**참조변수의 형변환**
- 사용할 수 있는 멤버의 개수를 조절하는 것
- 조상,자손 관계의 참조변수만 서로 형변환 가능
```
// 참조변수 형변환 예제
public class Ex7_8_Polymorphism {

	public static void main(String[] args) {
		FireEngine fe = new FireEngine();
		fe.water();
		fe.drive();
		
		Car car = (Car)fe; // 조상타입 <- 자손타입 형변환(Car) 생략 가능
		car.stop();
		//car.water(); 에러. 조상 클래스에 water() 메서드 없음
		
		FireEngine fe2 = (FireEngine)car; // 자손타입 <- 조상타입 형변환 생략 불가
		fe2.water();
	}
}

class Car {
	String color;
	int door;
	
	void drive() {
		System.out.println("drive, Brrrr~");
	}
	
	(void stop() {
		System.out.println("stop!!!");
	}
}

class FireEngine extends Car {
	void water() {
		System.out.println("water!!!");
	}
}
```

**instanceof 연산자**
- 참조변수의 형변환 가능여부 확인에 사용. 가능하면 true 반환
- 형변환 전에 반드시 instanceof로 확인하여야 함
```
void doWork(Car c) {
	if(c instanceof FireEngine) {
		FireEngine fe = (FireEngine)c;
		fe.water();
		...
	}
}
```

**매개변수의 다형성**
- 참조형 매개변수는 메서드 호출 시, 자신과 같은 타입 또는 자손타입의 인스턴스를 넘겨줄 수 있다. 
![매개변수의다형성](매개변수의다형성.png)

**여러 종류의 객체 배열로 다루기**
- 조상 타입의 배열에 자손들의 객체를 담을 수 있다.
![여러종류객체배열](여러종류객체배열.png)

**추상 클래스(abstract class)**
- 미완성 설계도. 미완성 메서드를 갖고 있는 클래스
```
abstract class Player {
	abstract void play(int pos);
	abstract void stop();
}
```
- 다른 클래스 작성에 도움을 주기 위한 것. 인스턴스 생성 불가
```
Player p = new Player(); // 에러. 추상 클래스의 인스턴스 생성 불가
```
- 상속을 통해 추상 메서드를 완성해야 인스턴스 생성 가능
```
class AudioPlayer extends Player {
	void play(int pos) { /* 내용 생략*/ } // 추상 메서드를 구현
	void stop() { /* 내용 생략*/ } // 추상 메서드를 구현
}
AudioPlayer ap = new AudioPlayer();
```

**추상 메서드(abstract method)**
- 미완성 메서드. 구현부(몸통,{})가 없는 메서드
```
/* 주석을 통해 어떤 기능을 수행할 목적으로 작성하였는지 설명한다. */
abstract 리턴타입 메서드이름();
```
- 꼭 필요하지만 자손마다 다르게 구현될 것으로 예상되는 경우
- 오버라이딩 해도 되지만, 추상 메서드를 사용하면 **강제성을 둘 수 있다.**
```
abstract class Player { // 추상 클래스
	abstract void play(int pos); // 추상 메서드
	abstract void stop(); // 추상 메서드
}

class AudioPlayer extends Player {
	void play(int pos) { /* 내용 생략 */ }  // 추상 메서드를 구현
	void stop() { /* 내용 생략*/ }	// 추상 메서드를 구현
}
// 추상 메서드를 일부만 구현하는 경우 아래와 같이 추상 제어자 표시 해줘야 함.
abstract class AbstractPlayer extends Player { 
	void play(int pos) { /* 내용 생략 */ } // 추상 메서드를 구현
}
```
- 추상 메서드 호출 가능(호출할 때는 선언부만 필요)
```
abstract class Player {
	boolean pause; // 일시정지 상태를 저장하기 위한 변수
	int currentPos; // 현재 Play 되고 있는 위치를 저장하기 위한 변수

	Player() { // 추상클래스도 생성자가 있어야 한다.
		pause = false;
		currentPos = 0;
	}
	/* 지정된 위치(pos)에서 재생을 시작하는 기능이 수행하도록 작성 */
	abstract void play(int pos); // 추상 메서드
	/* 재생을 즉시 멈추는 기능을 수행하도록 작성 */
	abstract void stop(); // 추상 메서드

	void play() {
		play(currentPos); // 추상 메서드 사용 가능(인스턴스 생성 후 사용할 것이기 떄문에)
	}
}
```

**추상 클래스의 작성**
- 여러 클래스에 공통적으로 사용될 수 있는 추상 클래스를 바로 작성하거나  
 기존 클래스의 공통 부분을 뽑아서 추상 클래스를 만든다.
- 추상화 코드는 구체화된 코드보다 유연하다. 변경에 유리
![추상클래스작성](추상클래스작성.png)  
```
// move의 방식이 다 다르므로 뽑아서 추상 클래스로 작성
public class Ex7_10 {
	public static void main(String[] args) {
		Unit[] group = {new Marine(), new Tank(), new Dropship()};
		
		for(int i = 0; i < group.length; i++) {
			group[i].move(100,200);
		}
	}
}
abstract class Unit {
	int x, y;
	abstract void move(int x, int y);
}
class Marine extends Unit {
	void move(int x, int y) {
		System.out.println("Marine is walking..");
		System.out.println("Marine[x="+x+", y="+y+"]");
	}
}
class Tank extends Unit {
	void move(int x, int y) {
		System.out.println("Tank is moving..");
		System.out.println("Tank[x="+x+", y="+y+"]");
	}
}
class Dropship extends Unit {
	void move(int x, int y) {
		System.out.println("Dropship is flying..");
		System.out.println("Dropship[x="+x+", y="+y+"]");
	}
}
```

**인터페이스(interface)**
- **추상 메서드의 집합** <- '프로그래밍 관점'
- 구현된 것이 전혀 없는 설계도. 껍데기(모든 멤버가 public)
```
interface 인터페이스이름 {
	public static final 타입 상수이름 = 값; // 'public','static','final' 생략 가능
	public abstract 메서드이름(매개변수목록); // 'public','abstract' 생략 가능
}

// 예시
interface PlayingCard {
	public static final int SPADE = 4;
	final int DIAMOND = 3; // public static final int DIAMOND = 3;
	static int HEART = 2; // public static final int HEART = 2;
	int CLOVER = 1; // public static final int CLOVER = 1;

	public abstract String getCardNumber();
	String getCardKind(); // public abstract String getCarKind();
}
```

**인터페이스의 상속**
- 인터페이스의 조상은 인터페이스만 가능(Object가 최고 조상이 아님)
- 다중 상속이 가능(추상 메서드는 충돌해도 문제 없음)
```
interface Fightable extends Movable, Attackable { } // 가능

interface Movable {
	void move(int x, int y);
}

interface Attackable {
	void attack(Unit u);
}
```

**인터페이스의 구현**
- 인터페이스에 정의된 추상 메서드를 완성하는 것. 몸통 '{}' 완성
- 일부만 구현하는 경우, 클래스 앞에 abstract를 붙여야 함
```
class 클래스이름 implements 인터페이스이름 {
	// 인터페이스에 정의된 추상메서드를 모두 구현해야 한다.
}
(
// 예시
class Fighter implements Fightable {
	public void move(int x, int y) { /* 내용 생략 */ }
	public void attack(Unit u) { /* 내용 생략 */ }
}
abstract class Fighter implements Fightable { // 메서드 하나만 구현 했으므로 'abstract' 붙여야 함
	public void move(int x, int y) { /* 내용 생략 */ }
}
```

**인터페이스를 이용한 다형성**
- 인터페이스도 구현 클래스의 부모? Yes
- 인터페이스 타입 매개변수는 인터페이스를 구현한 클래스의 객체만 가능
- 인터페이스를 메서드의 리턴타입으로 지정할 수 있다.
	- 인터페이스를 구현한 클래스의 인스턴스를 반환

**인터페이스의 장점**
- 두 대상(객체) 간의 '연결, 대화, 소통'을 돕는 '중간 역할'을 한다.
- 선언(설계)와 구현을 분리시킬 수 있게 한다.
- 인터페이스 덕분에 B가  변경되어도 A는 바꾸지 않을 수 있다.(느슨한 결합)
- 개발 시간을 단축할 수 있다.
- 변경에 유리한 유연한 설계가 가능하다.
- 표준화가 가능하다. ex) JDBC(Database 관련 interface 집합)
- 서로 관계없는 클래스들을 관계 맺어줄 수 있다.

**디폴트 메서드와 static 메서드**
- 인터페이스에 디폴트 메서드, static 메서드 추가 가능.(JDK 1.8 부터)
- 인터페이스에 새로운 메서드(추상 메서드)를 추가하기 어려움.
	- 해결책 -> 디폴트(default) 메서드
- 디폴트 메서드는 인스턴스 메서드(인터페이스 원칙 위반). '예외 사항'
- 디폴트 메서드가 기존의 메서드와 충돌할 때의 해결책
	- 여러 인터페이스의 디폴트 메서드 간의 충돌
		- 인터페이스를 구현한 클래스에서 디폴트 메서드를 오버라이딩해야 한다.
	- 디폴트 메서드와 조상 클래스의 메서드 간의 충돌
		- 조상 클래스의 메서드가 상속되고, 디폴트 메서드는 무시된다.

**내부 클래스(inner class)**
- 클래스 안의 클래스
- 내부 클래스의 장점
	- 내부 클래스에서 외부 클래스의 멤버들을 쉽게 접근할 수 있다.
	- 코드의 복잡성을 줄일 수 있다.(캡슐화)

**내부 클래스의 종류와 특징**
- 내부 클래스의 종류와 유효범위(scope)는 변수와 동일  
![내부클래스종류특징1](내부클래스종류특징1.png)  
![내부클래스종류특징2](내부클래스종류특징2.png)  

**내부 클래스의 제어자와 접근성**
- 내부 클래스의 제어자는 변수에 사용 가능한 제어자와 동일
- 기존에 class에는 public 과 (default) 만 붙일 수 있었던 것과 달리,
- private, protected, (default), public 모두 사용 가능
```
public class Ex7_12 {
	class InstanceInner {
		int iv = 100;
		// static int cf = 100; // 에러. static 변수 선언 불가
		final static int CONST = 100; // final static은 상수이므로 허용
	}
	
	static class StaticInner {
		int iv = 200;
		static int cv = 200;
	}
	
	void myMethod() {
		class LocalInner {
			int iv = 300;
			// static int cv = 300; // 에러. static 변수 선언 불가
			final static int CONST = 300; // final static은 상수이므로 허용
		}
		int i = LocalInner.CONST; // OK. 지역 변수는 해당 메서드 안에서 사용 가능
	}
	
	public static void main(String[] args) {
		System.out.println(InstanceInner.CONST);
		System.out.println(StaticInner.cv);
		StaticInner s = new StaticInner();
		System.out.println(s.iv); // iv는 인스턴스 생성 후에만 사용 가
		// System.out.println(LocalInner.CONST); // 에러. 지역 내부 클래스는 메서드 내에서
	}
}
```
```
class Outer {
	private int outerIv = 0;
	static int outerCv = 0;
	
	class InstanceInner{
		int iiv = outerIv; // 외부 클래스의 private멤버도 접근 가능
		int iiv2 = outerCv;
	}
	
	static class StaticInner {
		// static 클래스는 외부 클래스의 인스턴스멤버에 접근 불가
		// int siv = outerIv;
		static int scv = outerCv;
	}
	
	void myMethod() {
		int lv = 0; // 값이 바뀌지 않는 변수는 상수로 간주
		final int LV = 0; // JDK1.8부터 final 생략 가능
		
		class LocalInner { 
			int liv = outerIv;
			int liv2 = outerCv;
			// 외부 클래스의 지역변수 filnal이 붙은 변수(상수)만 접근 가능(JDK1.8 이전)
			int liv3 = lv; // 에러. JDK1.8 이전 버전까지만 에러
			int liv4 = LV;
			
			void method() {
				System.out.println(lv);
			}
		}
	}
}
```
```
public class Ex7_12 {
	public static void main(String[] args) {
		// 외부 클래스의 인스턴스를 먼저 생성해야 인스턴스 클래스의 인스턴스를 생성 가능
		Outer2 oc = new Outer2();
		Outer2.InstanceInner ii = oc.new InstanceInner();
		
		// 외부 클래스의 객체 생성 없이 사용 가능
		System.out.println("ii.iv : " + ii.iv);
		System.out.println("Outer2.StaticInner.cv : " + Outer2.StaticInner.cv);
		
		// static 내부 클래스의 인스턴스 생성 시 외부 클래스의 인스턴스를 먼저 생성하지 않아도 된다.
		Outer2.StaticInner si = new Outer2.StaticInner();
		System.out.println("si.iv : " + si.iv);
		
	}
}

class Outer2 {
	class InstanceInner {
		int iv = 100;
	}
	
	static class StaticInner {
		int iv = 200;
		static int cv = 300;
	}
	
	void myMethod() {
		class LocalInner {
			int iv = 400;
		}	
	}
}
```
```
class Ex7_13 {
	public static void main(String[] args) {
		Outer3 outer = new Outer3();
		Outer3.Inner inner = outer.new Inner();
		inner.method1();
	}
}

class Outer3 {
	int value = 10; // Outer3.this.value
	
	class Inner {
		int value = 20; // this.value
		
		void method1() {
			int value = 30;
			System.out.println("            value : " + value);
			System.out.println("       this.value : " + this.value);
			System.out.println("Outer3.this.value : " + Outer3.this.value);
		}
	}
}
```

**익명 클래스(anonymous class)**
- 이름이 없는 일회용 클래스. 정의와 생성을 동시에 한다.
```
new 조상클래스이름() {
	// 멤버 선언
}
또는
new 구현인터페이스이름() {
	// 멤버 선언
}
```
```
class Ex7_14 {
	Object iv = new Object() { void method() {}}; // 익명 클래스
	static Object cv = new Object() { void method() {}}; // 익명 클래스
	
	void myMethod() {
		Object lv = new Object() { void method() {}}; // 익명 클래스
	}
}
```
```
import java.awt.Button;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

class Ex7_15 {
	public static void main(String[] args) {
		Button b = new Button("Start");
		b.addActionListener(new EventHandler());
	}
}

class EventHandler implements ActionListener {
	public void actionPerformed(ActionEvent e) {
		System.out.println("ActionEvent occurred!!!");
	}
}
↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓

import java.awt.Button;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

public class Ex7_16 {
	public static void main(String[] args) {
		Button b = new Button("Start");
		b.addActionListener(new ActionListener() { // 익명 클래스로 변경
			public void actionPerformed(ActionEvent e) {
				System.out.println("ActioEvent occurred!!!");
			}
		});
	}
}
```


### **Ch8. 예외처리**
**프로그램 오류**
- 컴파일 에러(compile-time error) : 컴파일 할 때 발생하는 에러
	- Java 컴파일러 기능 : 구문체크, 번역, 최적화, 생략된 코드 추가
- 런타임 에러(run-time error) : 실행 중 발생하는 에러
	- 에러(error) : 프로그램 코드에 의해서 수습될 수 없는 심각한 오류
	- **예외(exception)** : 프로그램 코드에 의해서 수습될 수 있는 다소 미약한 오류
		- Exception 과 그 자손들
		- RuntimeException 과 그 자손들
- 논리적 에러(logical error) : 실행은 되지만, 작성 의도와 다르게 동작하는 것
  
**예외 클래스의 계층 구조**  
![상속계층도](상속계층도.png)  

**Exception과 RuntimeException**
- Exception클래스들 : 사용자의 실수와 같은 외적인 요인에 의해 발생하는 예외
- RuntimeException클래스들 : 프로그래머의 실수로 발생하는 예외  
![Exception](Exception.png)

**예외 처리하기 'try-catch문'**
- 예외처리(Exception Handling)
	- 정의 : 프로그램 실행 시 발생할 수 있는 예외의 발생에 대비한 코드를 작성하는 것
	- 목적 : 프로그램의 비정상 종료를 막고, 정상적인 실행상태를 유지하는 것
```
try {
	// 예외가 발생할 가능성이 있는 문장들을 넣는다.
} catch (Exception1 e1) {
	// Exception1이 발생했을 경우, 이를 처리하기 위한 문장을 적는다.
} catch (Exception2 e2) {
	// Exception2가 발생했을 경우, 이를 처리하기 위한 문장을 적는다.
} catch (Exception3 eN) {
	// ExceptionN이 발생했을 경우, 이를 처리하기 위한 문장을 적는다.
}
```
※ if문과 달리, try블럭이나 catch 블럭 내에 포함된 문장이 하나뿐이어도 괄호{} 생략 불가  

**try-catch 문에서의 흐름**
1. try 블럭 내에서 예외가 발생한 경우.
	1. 발생한 예외와 일치하는 catch블럭이 있는지 확인한다.
	2. 일치하는 catch블럭을 찾게 되면, 그 catch블럭 내의 문장들을 수행하고 전체 try-catch  
	문을 빠져나가서 그 다음 문장을 계속해서 수행한다. 만일 일치하는 catch블럭을 찾지 못하면,  
	예외는 처리되지 못한다. <- 프로그램 비정상 종
2. try 블럭 내에서 예외가 발생하지 않은 경우.
	1. catch블럭을 거치지 않고 전체 try-catch문을 빠져나가서 수행을 계속한다.
```
class Ex8_4 {
	public static void main(String[] args) {
		System.out.println(1);
		System.out.println(2);
		try {
			System.out.println(3);
			System.out.println(0/0);
			System.out.println(4); // 실행되지 않는다.
		} catch(Exception ae) {
			if(ae instanceof ArithmeticException) {
				System.out.println("true");
				System.out.println("ArithmeticException");
			} else {
				System.out.println("anotherException");
			}
		} // try-catch 끝
		System.out.println(6);
	} // main 메서드 끝
}

출력 : 
1
2
3
true
ArithmeticException
6
```

**printStackTrace()와 getMessage()**
- printStackTrace() : 예외발생 당시의 호출스택(Call Stack)에 있었던 메서드의 정보와 예외 메시지를 화면에 출력한다.
- getMessage() : 발생한 예외 클래스의 인스턴스에 저장된 메시지를 얻을 수 있다.
```
class Ex8_5 {
	public static void main(String[] args) {
		System.out.println(1);
		System.out.println(2);
		
		try {
			System.out.println(3);
			System.out.println(0/0);
			System.out.println(4);
		} catch(ArithmeticException ae) {
			ae.printStackTrace();
			System.out.println("예외 메시지 : " + ae.getMessage());
		}
		System.out.println(6);
	}
}

출력 :
1
2
3
java.lang.ArithmeticException: / by zero // printStackTrace()
	at Ex8_5.main(Ex8_5.java:8)
예외 메시지 : / by zero                  // getMessage()
6
```

**멀티 catch 블럭**
- 내용이 같은 catch블럭을 하나로 합친 것(JDK1.7부터)

**예외 발생시키기**
1. 연산자 new를 이용해서 발생시키려는 예외 클래스의 객체를 만든 다음
	- Exception e = new Exception("고의로 발생시켰음")
2. 키워드 'throw'를 이용해서 예외를 발생시킨다.
	- throw e;
```
class Ex8_6 {
	public static void main(String[] args) {
		try {
			Exception e = new Exception("고의로 발생시켰음");
			throw e;
		} catch(Exception e) {
			e.printStackTrace();
			System.out.println("에러메시지 : " + e.getMessage());
		}
		System.out.println("프로그램이 정상 종료되었음");
	}
}

출력:
java.lang.Exception: 고의로 발생시켰음
	at Ex8_6.main(Ex8_6.java:4)
에러메시지 : 고의로 발생시켰음 
프로그램이 정상 종료되었음
```

**checked 예외, unchecked 예외**
- checked 예외 : 컴파일러가 예외 처리 여부를 체크(예외 처리 필수)
- unchecked 예외 : 컴파일러가 예외 처리 여부를 체크 안함(예외 처리 선택)
```
class Ex8_7 {
	public static void main(String[] args) {
		try { // Exception과 그 자손은 compiler에서 에러 발생
			throw new Exception(); // Exception을 고의로 발생시킨다.
		} catch(Exception e) {}
		
		// RuntimeException과 그 자손은 예외처리를 해주지 않아도 컴파일 된다.
		throw new RuntimeException();
	}
}
```
**메서드에 예외 선언하기**
- 예외를 처리하는 방법
	- try-catch 문(직접 처리 or 은폐)
	- 예외 선언하기(예외 떠넘기기(알리기))
- 예외 선언 : 메서드가 호출 시 발생 가능한 예외를 **호출하는 쪽에** 알리는 것
```
void method() throws Exception1, Exception2, ... ExceptionN {
	// 메서드의 내용
}

// method()에서 Exception과 그 자손 예외 발생 가능
void method() throws Exception {
	// 메서드의 내용
}
```  
※ 예외를 발생시키는 'throw'와 예외를 메서드에 선언할 때 쓰는 'throws' 구분 필요  

- 아래 예제(Ex8_9) 결과를 통해 다음과 같은 사실을 알 수 있음
	- 예외가 발생했을 때, 모두 3개의 메서드가 호출 스택에 있었으며,
	- 예외가 발생한 곳은 제일 윗줄에 있는 method2() 라는 것과
	- main() -> method1 -> method2 순으로 호출 했다는 것
```
class Ex8_9 {
	public static void main(String[] args) throws Exception {
		method1();
	}
	
	static void method1() throws Exception{
		method2();
	}
	
	static void method2() throws Exception{
		throw new Exception();
	}
}

출력 : 
Exception in thread "main" java.lang.Exception
	at Ex8_9.method2(Ex8_9.java:12)
	at Ex8_9.method1(Ex8_9.java:8)
	at Ex8_9.main(Ex8_9.java:4)
```

**finally 블럭**
- 예외 발생 여부와 관계없이 수행되어야 하는 코드를 넣는다.
```
try {
	// 예외 발생 가능성 있는 문장들을 넣는다.
} catch (Exception1 e1) {
	// 예외 처리를 위한 문장을 넣는다.
} finally {
	// 예외의 발생여부에 관계없이 항상 수행되어야하는 문장들을 넣는다.
	// finally블럭은 try-catch문의 맨 마지막에 위치해야한다.
}
```  
※ try블럭 안에 return문이 있어서 try블럭을 벗어나갈 때도 finally블럭은 실행된다.  

**사용자 정의 예외 만들기**
- 우리가 직접 예외 클래스를 정의할 수 있다.
- 조상은 Exception과 RuntimeException 중에서 선택
- 문자열을 매개변수로 받는 생성자를 생성하여 에러메시지를 받을 수 있게 한다. 
```
// 가능하면 선택처리가 가능한 RuntimeException을 사용하고 꼭 필요한 경우 Exception 사용할 것
class MyException extends Exception {
	MyException(String msg) { // 문자열을 매개변수로 받는 생성자
		super(msg); // 조상인 Exception클래스의 생성자를 호출한다.
	}
}

※ super() : 조상 클래스의 생성자 'Exception(String msg)'를 호출
```
```
class Ex8_11 {
	public static void main(String[] args) {
		try {
			startInstall(); // 프로그램 설치에 필요한 준비를 한다.
			copyFiles(); // 파일들을 복사한다.
		} catch(SpaceException e) {
			System.out.println("에러 메시지 : "+e.getMessage());
			e.printStackTrace();
			System.out.println("공간을 확보한 후에 다시 설치하시기 바랍니다.");
		} catch(MemoryException me) {
			System.out.println("에러 메시지 : "+me.getMessage());
			me.printStackTrace();
			System.gc(); // Garbage Collection을 수행하여 메모리를 늘려준다.
			System.out.println("설치를 다시 시도하세요.");
		} finally {
			deleteTempFiles(); // 프로그램 설치에 필요했던 임시파일들을 삭제한다.
		} // try-catch-finally의 끝
	} // main의 끝
	
	static void startInstall() throws SpaceException,MemoryException {
		if(!enoughSpace()) { // 충분한 설치 공간이 없으면..
			throw new SpaceException("설치할 공간이 부족합니다.");
		}
		if(!enoughMemory()) { // 충분한 메모리가 없으면..
			throw new MemoryException("메모리가 부족합니다.");
		}
	}
	
	static void copyFiles() { /* 파일들을 복사하는 코드*/ }
	static void deleteTempFiles() { /* 임시파일을 삭제하는 코드*/ }
	
	static boolean enoughSpace() {
		// 설치하는데 필요한 공간이 있는지 확인하는 코드
		return false;
	}
	static boolean enoughMemory() {
		// 설치하는데 필요한 메모리 공간이 있는지 확인하는 코드
		return true;
	}
}

class SpaceException extends Exception {
	SpaceException(String msg){
		super(msg);
	}
}

class MemoryException extends Exception {
	MemoryException(String msg){
		super(msg);
	}
}

출력:
에러 메시지 : 설치할 공간이 부족합니다.
SpaceException: 설치할 공간이 부족합니다.
	at Ex8_11.startInstall(Ex8_11.java:22)
	at Ex8_11.main(Ex8_11.java:4)
공간을 확보한 후에 다시 설치하시기 바랍니다.
```

**예외 되던지기(Exception re-throwing)**
- 예외를 처리한 후에 다시 예외를 발생시키는 것
- 호출한 메서드와 호출된 메서드 양쪽 모두에서 예외처리하는 것
```
class Ex8_12 {
	public static void main(String[] args) {
		try {
			method1();
		} catch (Exception e) {
			System.out.println("main 메서드에서 예외가 처리되었습니다.");
		}
	}

	static void method1() throws Exception {
		try {
			throw new Exception();
		} catch(Exception e) {
			System.out.println("method1메서드에서 예외가 처리되었습니다.");
			throw e;
		}
	}
}

출력:
method1메서드에서 예외가 처리되었습니다.
main 메서드에서 예외가 처리되었습니다.
```

**연결된 예외(chained exception)**
- 한 예외가 다른 예외를 발생시킬 수 있다.
- 예외 A가 예외 B를 발생시키면, A는 B의 원인 예외(cause exception)가 된다.
	- Throwable initCause(Throwable cause) : 지정한 예외를 원인 예외로 등록
	- Throwable getCause() : 원인 예외를 반환
- 연결된 예외 사용 이유
	- 여러 예외를 하나로 묶어서 다루기 위해
	- checked 예외를 unchecked 예외로 변경하려 할 때 사용
```
public class Throwable implement Serializable {
	...
	private Throwable cause = this; // 객체 자신(this)을 원인 예외로 등록
	...
	// 자신 안에 다른 예외를 포함 시킴
	public synchronized Throwable initCause(Throwable cause) { 
		this.cause = cause; // cause를 원인 예외로 등록
		return this;
	}
	...
}
```
```
class Ex8_13 {
	public static void main(String[] args) {
		try {
			install();
		} catch(InstallException e) { // catch는 단어 뜻 그대로 발생된 예외를 받는 역할을 한다.
			e.printStackTrace();
		} catch(Exception e) {
			e.printStackTrace();
		}
	} // main의 끝
	
	static void install() throws InstallException {
		try {
			startInstall(); // 프로그램 설치에 필요한 준비를 한다.
			copyFiles(); // 파일들을 복사한다.
		} catch (SpaceException2 e) {
			InstallException ie = new InstallException("설치 중 예외발생"); // 예외 생성
			ie.initCause(e); // 예외를 연결
			throw ie;
		} catch (MemoryException2 me) {
			InstallException ie = new InstallException("설치 중 예외발생"); // 예외 생성
			ie.initCause(me); // 예외를 연결
			throw ie;
		} finally {
			deleteTempFiles(); // 프로그램 설치에 사용된 임시파일들을 삭제한다.
		} // try 메서드의 끝 
	}
	
	static void startInstall() throws SpaceException2, MemoryException2 {
		if(!enoughSpace()) {
			throw new SpaceException2("설치할 공간이 부족합니다.");
		}
		if(!enoughMemory()) {
			throw new MemoryException2("메모리가 부족합니다.");
			// Exception 을 RuntimeException으로 만들어주기 위한 연결
			// throw new RuntimeException(new MemoryException("메모리가 부족합니다.")); 
		}
	} // startInstall 메서드의 끝
	
	static void copyFiles() {/* 파일들을 복사하는 코드 */}
	static void deleteTempFiles() {/* 임시파일들을 삭제하는 코드 */}
	
	static boolean enoughSpace() {
		// 설치하는데 필요한 공간이 있는지 확인하는 코드
		return true;
	}
	static boolean enoughMemory() {
		// 설치하는데 필요한 메모리공간이 있는지 확인하는 코드
		return false;
	}
}

class InstallException extends Exception {
	InstallException(String msg){
		super(msg);
	}
}
class SpaceException2 extends Exception {
	SpaceException2(String msg){
		super(msg);
	}
}
class MemoryException2 extends Exception {
	MemoryException2(String msg){
		super(msg);
	}
}

출력:
InstallException: 설치 중 예외발생
	at Ex8_13.install(Ex8_13.java:22)
	at Ex8_13.main(Ex8_13.java:5)
Caused by: MemoryException2: 메모리가 부족합니다.
	at Ex8_13.startInstall(Ex8_13.java:35)
	at Ex8_13.install(Ex8_13.java:15)
	... 1 more
```

### **Ch9. java.lang 패키지와 유용한 클래스**

**Object 클래스**
- 모든 클래스의 최고 조상. 오직 11개의 메서드만을 가지고 있다.
- notify(), wait() 등은 쓰레드와 관련된 메서드이다.
![Object클래스의메서드](Object클래스의메서드.png)  

**equals(Object obj)**
- 객체 자신(this)과 주어진 객체(obj)를 비교한다. 같으면 true, 다르면 false
- Object클래스의 equals()는 객체의 주소를 비교(참조변수 값 비교)
```
// 각 객체의 주소를 비교하게끔 설계되어 있다.
public boolean equals(Object obj) {
	return (this == obj);
}
```
```
public class Ex9_1 {
	public static void main(String[] args) {
		Value v1 = new Value(10);
		Value v2 = new Value(10);
		
		if(v1.equals(v2)) {
			System.out.println("v1과 v2는 같습니다.");
		} else {
			System.out.println("v1과 v2는 다릅니다.");
		}
	} // main 끝
}

class Value{
	int value;	
	Value(int value){ // 생성자
		this.value = value;
	}
}

출력 : v1과 v2는 다릅니다.
```

**equals(Object obj)의 오버라이딩**
- 인스턴스 변수(iv)의 값을 비교하도록 equals()를 오버라이딩해야 한다.
```
class Person {
	long id;
	
	public boolean equals(Object obj) { // equals() 오버라이딩
		if(obj instanceof Person) {
			// Object의 경우 id 변수를 가지고 있지 않으므로 Person으로 형변환 해줘야 한다.
			return id == ((Person)obj).id; // id를 비교해주는 코드
		} else {
			return false; // 타입이 Person이 아니면 값을 비교할 필요 없다.
		}
	}
	
	Person(long id){ // 생성자
		this.id = id;
	}
}

class Ex9_2 {
	public static void main(String[] args) { 
		Person p1 = new Person(8011081111222L);
		Person p2 = new Person(8011081111222L);
		
		if(p1.equals(p2)) {
			System.out.println("p1과 p2는 같은 사람 입니다.");
		} else {
			System.out.println("p1과 p2는 다른 사람 입니다.");
		}
	}
}

출력 : p1과 p2는 같은 사람 입니다.
```

**hashCode()**
- 객체의 해시코드(hash code)를 반환하는 메서드. '객체의 지문' 이라고도 부른다.
- Object클래스의 hashCode()는 객체의 주소를 int로 변환해서 반환
- equals()를 오버라이딩하면, hashCode()도 오버라이딩해야 한다.  
	- **★equals()의 결과가 true인 두 객체의 해시코드는 같아야 하기 때문★**
- System.identityHashCode(Object obj)는 Object클래스의 hashCode()와 동일
	- 오버라이딩 이전의 해시코드가 필요할 때 사용
- 32bit JVM -> 64 bit JVM 되면서 hashcode() 주소값이 겹치는 경우도 발생 가능
	- 32bit의 경우 주소값이 4byte 범위로 int 반환 가능하지만
	- 64bit의 경우 주소값이 8byte 범위로 int로 전부 반환 불가하여 겹칠수도 있음
```
public class Object {
	...
	public native int hashCode();
	...
}
※ native 메서드 : OS의 메서드(C 언어)
```
```
class Ex9_3 {
	public static void main(String[] args) {
		String str1 = new String("abc");
		String str2 = new String("abc");
		
		System.out.println(str1.equals(str2)); // true
		System.out.println(str1.hashCode()); // 96354
		System.out.println(str2.hashCode()); // 96354
		System.out.println(System.identityHashCode(str1)); // 204349222
		System.out.println(System.identityHashCode(str2)); // 231685785
		}
}
```

**toString(), toString()의 오버라이딩**
- toString() : 객체를 문자열(String)으로 변환하기 위한 메서드
```
public String toString() { // Object클래스의 toString()
	return getClass().getName()+"@"+Integer.toHexString(hashCode());
}
```
```
// toString() 사용 예제
class Card {
	String kind;
	int number;
	
	Card(){
		this("SPADE", 1); // 'this'로 다른 생성자 호출 '첫 줄에서만 가능!'
	}
	
	Card(String kind, int number){
		this.kind = kind;
		this.number = number;
	}
}

class Ex9_4 {
	public static void main(String[] args) {
		Card c1 = new Card();
		Card c2 = new Card();

		System.out.println(c1.toString());
		System.out.println(c2.toString());
	}
}

출력:
Card@1963006a // 객체의 주소를 출력한다.
Card@6d9c638
```
```
// toString() 오버라이딩 예제
class Card2 {
	String kind;
	int number;
	
	Card2(){
		this("SPADE", 1);
	}
	
	Card2(String kind, int number){
		this.kind = kind;
		this.number = number;
	}
	
	public String toString() { // toString() 오버라이딩
		return "kind : " + kind + ", number : " + number; 
	}
}

class Ex9_5 {
	public static void main(String[] args) {
		Card2 c1 = new Card2();
		Card2 c2 = new Card2("CLOVER", 7);
		
		System.out.println(c1.toString());
		System.out.println(c2.toString());
	}
}

출력:
kind : SPADE, number : 1 // 오버라이딩한 양식에 맞추어 출력
kind : CLOVER, number : 7
```

**String 클래스**
- String 클래스 = 데이터(char[]) + 메서드(문자열 관련)
```
public final class String implements java.io.Serializable, Comparable {
	private char[] value;
	...
```
- 내용을 변경할 수 없는 불변(immutable) 클래스
![String불변클래스](String불변클래스.png)

- 덧셈 연산자(+)를 이용한 문자열 결합은 성능이 떨어짐  
  -> 문자열의 결합이나 변경이 잦다면, 내용을 변경 가능한 StringBuffer를 사용

**문자열의 비교**
- String str = "abc" 와 String str = new String("abc"); 의 비교  
![문자열의비교](문자열의비교.png)  

**문자열 리터럴**
- 문자열 리터럴은 프로그램 실행 시 자동으로 생성된다.(constant pool에 저장)
- 같은 내용의 문자열 리터럴은 하나만 만들어진다.

**빈 문자열("", empty string)
- 내용이 없는 문자열. 크기가 0인 char형 배열을 저장하는 문자열
```
String str = ""; // str을 빈 문자열로 초기화
```
- 크기가 0인 배열을 생성하는 것은 어느 타입이나 가능
```
char[] chArr = new char[0]; // 길이가 0인 char 배열
int[] iArr = {}; // 길이가 0인 int 배열
```
- 문자(char)와 문자열(String)의 초기화
![문자문자열초기화](문자문자열초기화.png)  

**String클래스의 생성자와 메서드**  
![String생성자메서드1](String생성자메서드1.png)  
![String생성자메서드2](String생성자메서드2.png)  
![String생성자메서드3](String생성자메서드3.png)  
![String생성자메서드4](String생성자메서드4.png)  
![String생성자메서드5](String생성자메서드5.png)  
![String생성자메서드6](String생성자메서드6.png)  
![String생성자메서드7](String생성자메서드7.png)  

**join()과 StringJoiner**
- join() 은 여러 문자열 사이에 구분자를 넣어서 결합한다.
```
String animals = "dog,cat,bear"; 
String[] arr = animals.split(","); // 문자열을 ','를 구분자로 나눠서 배열에 저장
String str = String.join("-", arr); // 배열의 문자열을 '-'로 구분해서 결합
System.out.println(str); // dog-cat-bear
```

**문자열과 기본형 간의 변환**
- 숫자를 문자열로 바꾸는 방법
```
int i = 100;
String str1 = i + ""; // 100을 "100"으로 변환하는 방법1
String str2 = String.valueOf(i); // 100을 "100"으로 변환하는 방법2
```
- 문자열을 숫자로 바꾸는 방법
```
int i = Integer.parseInt("100");
int i2 = Integer.valueOf("100");
// 원래는 반환 타입이 Integer 이나 오토박싱에 의해 int로 자동 변환됨
Integer i2 = Integer.valueOf("100"); // 원래는 반환 타입 Integer
```
![문자열과기본형간변환](문자열과기본형간변환.png)  

**StringBuffer클래스**
- String 처럼 문자형 배열(char[])을 내부적으로 가지고 있다.
```
public final class String Buffer implements java.io.Serializable {
	private char[] value;
	...
}
```
- 그러나, String 과 달리 내용을 변경할 수 있다.(mutable)
```
StringBuffer sb = new StringBuffer("abc"); // sb = "abc"
sb.append("123"); // sb = "abc123"
```

**StringBuffer 생성자**
- 배열은 길이 변경불가. 공간이 부족하면 새로운 배열 생성해야 한다.
	1. 기존 배열보다 더 큰 배열을 생성
	2. 기존 배열 -> 새로운 배열 로 내용 복사
	3. 참조 변경
- StringBuffer는 저장할 문자열의 길이를 고려해서 적절한 크기로 생성해야 한다.
```
public StringBuffer(int length) {
	value = new char[length];
	shared = false;
}

public StringBuffer() {
	this(16); // 버퍼의 크기를 지정하지 않으면 그 크기는 16이 된다.
}

public StringBuffer(String str) { 
	this(str.length() + 16)
	append(str);
}
```

**StringBuffer의 변경**
- StringBuffer는 String과 달리 내용 변경이 가능하다.
- append()는 지정된 내용을 StringBuffer에 추가 후, StringBuffer의 참조를 변환

**StringBuffer의 비교**
- StringBuffer는 equals()가 오버라이딩되어있지 않다.(주소비교로 되어있음.)
```
StringBuffer sb = new StringBuffer("abc");
StringBuffer sb2 = new StringBuffer("abd");

System.out.println(sb == sb2); // false
System.out.println(sb.equals(sb2)); // false
```
- StringBuffer를 String으로 변환 후에 equals()로 비교해야 한다.
```
String s = sb.toString(); // sb를 String으로 변환
String s2 = sb2.toString();

System.out.println(s.equals(s2)); // true
```

**StirngBuffer의 생성자와 메서드**  
![StringBuffer생성자메서드1](StringBuffer생성자메서드1.png)  
![StringBuffer생성자메서드2](StringBuffer생성자메서드2.png)  
![StringBuffer생성자메서드3](StringBuffer생성자메서드3.png)  
![StringBuffer생성자메서드4](StringBuffer생성자메서드4.png)  
![StringBuffer생성자메서드5](StringBuffer생성자메서드5.png)  

**StringBuilder**
- StringBuffer는 동기화되어 있다. 멀티 쓰레드에 안전(thread-safe)
- 멀티 쓰레드 프로그램이 아닌 경우, 동기화는 불필요한 성능저하  
  이럴 땐 StringBuffer 대신 StringBuilder를 사용하면 성능 향상
- 변경 시, 참조변수 선언부와 생성자만 바꾸면 된다.(메서드 똑같음)

**Math 클래스**
- 수학 관련 static메서드의 집합
```
// Math 클래스의 상수
public static final double E = 2.7182818284590452354; // 자연로그의 밑
public static final double PI = 3.14159265358979323846; // 원주율
```
- round()로 원하는 소수점 아래 세 번째 자리에서 반올림하기
	1. 원래 값에 100을 곱한다.
		- 90.7552 * 100 -> 9075.52
	2. 위의 결과에 Math.round()를 사용한다.
		- Math.round(9075.52) -> 9076
	3. 위의 결과를 다시 100.0으로 나눈다.
		- 9076 / 100.0 -> 90.76 // 나누기할 때 double로 나눠야 소수점 표시됨(주의)  
![Math클래스메서드1](Math클래스메서드1.png)  
![Math클래스메서드2](Math클래스메서드2.png)  

**래퍼(wrapper) 클래스**
- 8개의 기본형을 객체로 다뤄야할 때 사용하는 클래스. 기본형 값을 감싸는 클래스.
```
public final class Integer extends Number implements Comparable {
	...
	private int value;
	...
}
```
![Wrapper클래스](Wrapper클래스.png)  
```
class Ex9_14 {
	public static void main(String[] args) {
		Integer i = new Integer(100);
		Integer i2 = new Integer(100);
		
		System.out.println("i==i2 ? "+(i==i2));
		System.out.println("i.equals(i2) ? "+i.equals(i2));
		System.out.println("i.compareTo(i2) = "+i.compareTo(i2));
		System.out.println("i.toString() = "+i.toString());
		
		System.out.println("MAX_VALUE = "+Integer.MAX_VALUE);
		System.out.println("MIN_VALUE = "+Integer.MIN_VALUE);
		System.out.println("SIZE = "+Integer.SIZE+" bits");
		System.out.println("BYTES = "+Integer.BYTES+"bytes");
		System.out.println("TYPE = "+Integer.TYPE);
	}
}

출력 : 
i==i2 ? false
i.equals(i2) ? true
i.compareTo(i2) = 0
i.toString() = 100
MAX_VALUE = 2147483647
MIN_VALUE = -2147483648
SIZE = 32 bits
BYTES = 4bytes
TYPE = int
```

**Number 클래스**
- 모든 숫자 래퍼 클래스의 조상.
![Number클래스](Number클래스.png)  
```
public abstract class Number implements java.io.Serializable {
	public abstract int intValue();
	public abstract long longValue();
	public abstract float floatValue();
	public abstract double doubleValue();

	public byte byteValue() {
		return (byte)intValue();
	}

	public short shortValue() {
		return (short)intValue();
	}
}
```

**문자열을 숫자로 변환하기**
- 문자열을 숫자로 변환하는 다양한 방법
```
int i = new Integer("100").intValue(); // floatValue(), longValue(),...
int i2 = Integer.parseInt("100"); // 주로 이 방법을 많이 사용한다.
int i3 = Integer.valueOf("100");
```
![문자열숫자변환](문자열숫자변환.png)  
- n진법의 문자열을 10진수 숫자로 변환하는 방법
```
int i4 = Integer.parseInt("100",2);  // 100(2) -> 4
int i5 = Integer.parseInt("100",8);  // 100(8) -> 64
int i6 = Integer.parseInt("100",16); // 100(16) -> 256
int i7 = Integer.parseInt("FF",16);  // FF(16) -> 255
int i8 = Integer.parseInt("FF");     // NumberFormatException 발생
```

**오토박싱 & 언박싱**
- 오토박싱(autoboxing) : 기본형 값을 래퍼 클래스의 객체로 자동 변환해주는 것
- 언박싱(unboxing) : 래퍼 클래스의 객체를 기본형 값으로 자동 변환해주는 것
```
ArrayList<Integer> list = new ArrayList<Integer>();

list.add(10);            // 오토박싱. 10 -> new Integer(10)
int value = list.get(0); // 언박싱 new Integer(10) -> 10
```
- JDK1.5 이전에는 기본형과 참조형 간의 연산이 불가능
![오토박싱언박싱](오토박싱언박싱.png)
```
class Ex9_16 {
	public static void main(String[] args) {
		int i = 10;
		
		// 기본형을 참조형으로 형변환(형변환 생략 가능)
		Integer intg = (Integer)i; // Integer intg = Integer.valueOf(i);
		Object obj = (Object)i; // Object obj = (Object)Integer.valueOf(i);
		
		Long lng = 100L; // Long lng = new Long(100L);
		
		int i2 = intg + 10; // 참조형과 기본형 간의 연산 가
		long l = intg + lng; // 참조형 간의 덧셈도 가
		
		Integer intg2 = new Integer(20);
		int i3 = (int)intg2; // 참조형을 기본형으로 형변환도 가능(형변환 생략가능)
	}
}
```
![오토박싱언박싱예제](오토박싱언박싱예제.png)  

