## DFS(Depth First Search)와 BFS(Breadth First Search)
DFS와 BFS는 **맹목적 탐색(blind search)**방법의 일부들로 맹목적 탐색은 이미 정해진 순서에 따라 상태 공간 그래프(문제 해결 과정에서 나타나는 각 국면을 데이터화)를 **점차 형성해 가면서** 해를 탐색하는 방법을 말한다.  
  
![DFS와BFS](dfs_bfs.gif)  
※ 그림 출처 : spartacodingclub - 알고보면 알기쉬운 알고리즘 강의자료  
  
### DFS(깊이 우선 탐색_Depth First Search)
1. **깊이 우선 탐색(DFS)이란?**  
갈 수 있는만큼의 깊이(트리에서는 리프)에 도달할 때까지 아래쪽으로 내려가면서 검색하는 것을 우선으로 하는 방법이다. 더 이상 검색할 곳이 없으면 일단 부모 노드로 돌아가고 그 뒤 다시 다른 자식 노드로 내려간다. OPEN List는 보통 Stack을 사용한다.  
DFS 는 끝까지 파고드는 것이라, 그래프의 최대 깊이 만큼만 공간을 요구하여 공간을 적게 쓴다는 장점이 있다. 그러나 같은 이유로 목표에 이르는 경로가 다수인 문제에 대해 깊이 우선 탐색은 해에 다다르면 탐색을 끝내버리므로, 이때 얻어진 해는 최적이 아닐 수 있다.  
-> 최단 경로 탐색에는 DFS 보다 BFS로 접근하는 것이 바람직하다.
  
2. **깊이 제한과 백트래킹**  
탐색 과정이 한없이 깊이 진행되는 것을 막기 위해 **깊이 제한(depth bound)**을 사용한다. 이 때, 조건문 등을 이용하여 깊이 제한에 도달까지 목표노드가 발견되지 않거나 순환할 경우 부모노드로 되돌아가게 하고, 이전과는 다른 노드를 방문하는 명령어를 적용하여 새로운 자식노드를 생성한다.  
여기서 부모노드로 되돌아오는 과정을 백트래킹(backtracking)이라 한다.  
  
3. **★알고리즘★**  
우선 그래프에서의 **깊이(다시 부모 노드로 돌아올 조건)를 결정할 필요**가 있다.(트리의 경우 자손 간의 간선이 없으므로 더이상 나아갈 간선이 없는 경우가 그 깊이가 된다.) 일반적으로 그래프에서는 루트 노드(출발점)의 깊이를 0으로 하며, 임의의 노드의 깊이는 이의 부모 중 가장 깊이가 작은 것(루트로부터 간선 길이가 가장 짧은 것)의 깊이에 1을 더한 값으로 정의한다.  
계속해서 자손 노드로 나아가면서 더 나아갈 수 있는 경우에는 깊이를 더 깊게하고 더 이상 나아갈 수 없는 경우(후계 노드에 방문하지 않은 간선이 없는 경우)에는 부모 노드로 되돌아 가게 하는 과정을 거치게 된다.  
여기서 알 수 있는 것은 일반적인 그래프를 탐색하는 경우라도 탐색 과정에 의하여 얻어지는 노드들과 간선들은 역시 탐색 트리를 형성한다는 것이다. 즉, 포인터들은 오직 하나의 부모를 가리키게 된다.  
```
깊이 우선 탐색의 알고리즘 순서(재귀, 반복문 등 구현 가능)
1. 노드를 방문하고 **깊이 우선으로 인접한** 노드를 방문한다.
2. 또 그 노드를 방문해서 **깊이 우선으로 인접한** 노드를 방문한다.(같은 과정의 반복(반복문, 재귀 구현 가능))
3. **만약 끝(가장 깊은 위치)에** 도달했다면 리턴한다.(리턴 조건(깊이 결정))
```

- **★★★★주의할 점★★★★**
    - 그래프 구조에 DFS를 적용할 경우 **'탈출 조건(위에서 언급한 '깊이 결정')'**을 명확히 할 필요가 있다.(실제로, [백준 1260 'DFS와 BFS' 문제](https://github.com/beadoer1/algorithm/blob/master/20210316/1260.py)에서는 출발점에 간선이 아예 없는 경우를 조건에서 빼먹어 고생하였다.)

  
### BFS(너비 우선 탐색_Breadth First Search)
1. **너비 우선 탐색(DFS)이란?**  
시작 정점을 방문한 후 시작 정점에 인접한 모든 정점들을 우선 방문하는 방법이다. 더 이상 방문하지 않은 정점이 없을 때까지 방문하지 않은 모든 정점들에 대해서도 너비 우선 검색을 적용한다. OPEN List 는 큐를 사용해야만 레벨 순서대로 접근이 가능하다.  
BFS의 경우 루트와 가까운 노드들부터 순차적으로 접근하므로 최단 경로를 찾는데 유리하다. 모든 분기되는 수를 다 보기 때문이다. 그러나, 모든 분기되는 수를 다 저장하다보니 공간을 많이 써야하고, 모든 걸 다 보고 오다보니 시간이 더 오래걸릴 수 있다.  
```
너비 우선 탐색의 알고리즘 순서(재귀, 반복문 등 구현 가능)
1. 노드를 방문하고 **너비 우선으로 인접한** 노드를 방문한다. 이 때, 큐(Queue)를 사용하여 모든 인접한 노드를 먼저 넣어놓고 FIFO 순서로 방문한다.
2. 인접한 노드를 방문해서 **너비 우선으로 인접한** 노드를 큐에 넣고, 큐에 있는 다음 순서의 노드에 방문한다.(같은 과정의 반복(반복문, 재귀 구현 가능))
3. **만약 끝(가장 깊은 위치)에** 도달했다면(큐에 더이상 방문할 노드가 없다면) 리턴한다.
```
  
  
- 참고 자료
    1. [위키백과 - '깊이 우선 탐색'](https://ko.wikipedia.org/wiki/%EA%B9%8A%EC%9D%B4_%EC%9A%B0%EC%84%A0_%ED%83%90%EC%83%89) 
    2. [위키백과 - '너비 우선 탐색'](https://ko.wikipedia.org/wiki/%EA%B9%8A%EC%9D%B4_%EC%9A%B0%EC%84%A0_%ED%83%90%EC%83%89) 
    3. 도서 - Do it! 자료구조와 함께 배우는 알고리즘 입문(Python)
    4. 강의자료 - spartacodingclub(알고보면 알기쉬운 알고리즘)