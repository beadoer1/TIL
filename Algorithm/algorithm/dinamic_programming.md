### 동적 계획법 (Dinamic Programming)
- '동적계획법'의 경우 블로그에 공들여 쓴 것이 있어서 해당 글로 정리하였다.  
  
### **재귀함수 혹은 같은 과정을 여러번 처리해서 출력해야하는 경우**에는 '동적계획법'을 사용하자. 
일단, 위 이야기는 '동적계획법(Dynamic Programming)'을 알게된 지금은 너무 당연한 이야기일 수 있지만 그 전까지는 몰라서 못써먹던 개념이라 '이론과 실제의 병행'이 느껴진 부분으로 WIL에 남겨본다. 간단하게 '**동적계획법**'은 `'문제를 결정하는 과정이 단계 별로 연결되어있는 경우, 각 단계의 결과가 달성하고자 하는 최종 목표에도 영향을 미치게 된다. 이 때, 작은 단계부터 각 단계 별로 최적값을 구하고 다음 단계로 넘기는 기법.'` 정도로 이야기 할 수 있겠다. 뭔가 앞서 배웠던 것들이 잔상처럼 남는다. 동적계획법을 배웠는데 왜 재귀가 떠오르는지 모르겠다.  
  
재귀 이야기를 꺼낸 김에 재귀를 먼저 예로 들어보자. 재귀의 구현 방식은 실제로 위에 이야기 한 동적계획법 설명과 정확히 일치한다. 이전 단계까지의 답이 있어야만 최종 결과를 도출할 수 있기 때문이다. 만약, 내가 num(n)을 num(n-1)+num(n-2)라는 재귀식을 가지고 num(0)=0, num(1)=1 인 함수를 짰다고 가정해보자. 그럼 아래와 같은 순서를 거치게 된다.
```
1. 먼저 num(n)을 구하려면 num(n-1)을 알아야 하므로 이를 구하기 위해 num(n-1) = num(n-2)+num(n-3)을 실행한다. 
2. 그럼 다시 위 1번의 num(n-2)를 구해야 하므로 num(n-2) = num(n-3)+num(n-4) 를 구한다.
3. 위 과정을 계속 반복(...)해서 마지막에는 num(2) = num(1)+num(0) = 1+0 = 1 이라는 값에 도달한다.
4. 됐다! 이제 num(3) 다시 올라가 num(3) = num(2)+num(1) = 1+1 = 2임을 알게됐다. 
5. 그럼 num(4)로 다시 올라가 num(4) = num(3)+num(2) = 2 + num(2) 가 되고,
6. 이제는 다시 num(2)를 구해야 하니 num(2) = num(1)+num(0) = 1+0 = 1 이라는 값에 도달한다.
7. 좋아! num(4) = 2 + 1 = 3 이 됨을 알 수 있다.
8. 다시 num(5)로 다시 올라가 num(5) = num(4)+num(3) = 3 + num(3) 이되고..
9. 다시 num(3)을 구해야 하니...  
```
위 과정을 보고있으면 '대체 num(2), num(3)은 앞에 구해놓고 왜 또 구하고 있는거지??'라는 의문을 가지게 된다. 여기서 **Memoization(메모이제이션)ㄴ**이라는 개념이 등장한다. 이는 간단하게 `'메모하여 놓음'` 정도의 의미로 볼 수 있는데, 우리가 가졌던 의문은 3,4번 과정을 거치며 num(2)=1,num(3)=2 라는 것을 자연스럽게 우리 머릿속에 '메모이제이션'했기 때문에 생기는 것이다. 그리고 바로 이 메모이제이션 기능을 프로그램에 넣는 것이 동적계획법이다.   
  
위 내용을 통해 우리가 배운 컴퓨터 프로그래밍에서의 '**동적계획법**'이란 `'동적계획법'을 통해 결론을 도출해야하는 문제의 각 단계 별 최적값을 '메모이제이션'하여 향후에 필요할 때 다시 꺼내어 보는 것'` 을 의미함을 알 수 있다. 이를 적용하면 위 순서에서 3,4번을 거치며 알게된 num(3)=2, num(2)=1이라는 결과값을 어딘가 메모해두고 num(4)를 구하는 5번 단계를 진행할 때 그 메모를 이용해 바로 문제를 풀 수 있게 된다. 또한, 다시 최초의 재귀식인 num(n) = num(n-1)+num(n-2)로 돌아갔을 때 남아있는 num(n-2)의 값은 다시 구할 필요도 없이 메모해놓은 값을 사용하면되니, 시간을 엄청나게 절약할 수 있는 것이다. 실제로 시간 복잡도가 O(n^2)에서 O(n)으로 변하게 된다.
  
나는 이것을 하나의 '**데이터베이스를 만드는 것**'으로 이해했다. 이는 두가지 조건만 만족하면 어디든 사용할 수 있다. 하나는 `'하나의 결론에 도달하기 위해 여러 단계가 필요하고 각 단계가 최적값을 가져야 한다.'` 이며, 두 번째는 `'해당 단계들이 반복해서 일어난다.'` 이다. 꼭 재귀가 아니어도 온갖 간단한 것들이 여기에 포함된다. 예를 들어 일정 숫자 사이에 있는 소수를 전부 구하는 [백준 4948번 '베르트랑 공준' 문제](https://www.acmicpc.net/problem/4948)도 동적계획법을 사용할 수 있다고 볼 수 있다. 이 문제는 크게 두 단계로 나눠지는데 '1) 0부터 2n 사이의 소수를 구한다.'와 '2) n부터 2n 사이의 소수를 찾는다.' 이다. 이 때 이 문제에 동적계획법이 적용된다고 한 이유는 '입력값을 여러개 받기 때문'이다. 입력값을 여러개 받아 매 입력값 n 마다 n부터 2n 사이의 소수를 출력해야하기 때문에, 자연스레 '1) 0부터 2n 사이의 소수를 구한다.'라는 단계가 반복되게 된다. 이를 동적계획법을 이용하여 입력받은 숫자 중 가장 큰 값 M에 대해 0~2M 사이에 있는 소수를 모두 구해 메모이제이션 해놓으면, 그보다 작은 숫자들에 대한 답을 구할 때는 그저 2)번 과정만 거치면 되는 것이다.  
  
사실 계속해서 동적계획법을 사용하고 있었던 것이나 다름 없는데, 좀 더 큰 관점에서 문제를 바라볼 수 있게된 것 같다. 그리고 풀이법을 떠올릴 때 좀 더 뚜렷해진 기분도 든다.  